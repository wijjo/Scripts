#!/usr/bin/env python

import sys
import os
import time
import zipfile

from lib import import_python_misc
import python_misc.cli as cli
import python_misc.git as git
import python_misc.logger as logger
import python_misc.run as run
import python_misc.utility as utility


class G:
    state_file_name = 'giv.current'
    workspace_script = 'giv_workspace.sh'


#===============================================================================
def main():
#===============================================================================
    parser = cli.Parser(
        'Various commands for working in a Git environment.',
        cli.Boolean('dryrun', "perform dry run - display, but don't execute commands",
                    '-n', '--dry-run'),
        cli.Boolean('pause', "pause before executing each command",
                    '-p', '--pause'),
        cli.Boolean('verbose', "enable verbose messages",
                    '-v', '--verbose')
    )
    parser.parse()
    logger.set_verbose(parser.cmdargs.verbose)
    parser.run()


#===============================================================================
@cli.Command(
    name='pending',
    description='List uncommitted changes.',
    args=[
        cli.String('format', 'format specification: l=long, s=short (default)',
                   '-f', '--format', default='s'),
        cli.String('order', 'order specification: t=time, n=name (default)',
                   '-o', '--order', default='n'),
    ],
)
#===============================================================================
def _pending(runner):
    if runner.cmdargs.format not in ['l', 's']:
        logger.abort('Format must be "s" (short) or "l" (long).',
                     'Short format is the default')
    if runner.cmdargs.order not in ['n', 't']:
        logger.abort('Order must be "n" (natural) or "t" (time).',
                     'Natural ordering is the default')
    root_dir = git.git_project_root()
    save_dir = os.getcwd()
    os.chdir(root_dir)
    try:
        if runner.cmdargs.order == 't':
            changes = git.get_changes_by_time()
        else:
            changes = git.get_changes()
        for change in changes:
            if change.path2:
                path = change.path2
            else:
                path = change.path
            if runner.cmdargs.format == 'l':
                try:
                    col1 = time.strftime('%x  %X', time.localtime(os.stat(path).st_mtime))
                except OSError:
                    col1 = '(deleted)'
                print '%3s  %17s  %s' % (change.flag, col1, path)
            else:
                print path
    finally:
        os.chdir(save_dir)


#===============================================================================
@cli.Command(
    name='snapshot',
    description='Archive uncommitted changes and capture a patch diff.',
    args=[
        cli.Boolean('all', 'include unmanaged files in archive', '-a', '--all'),
        cli.String('output', 'output directory', '-o', '--output', default='../WIP'),
    ],
)
#===============================================================================
def _snapshot(runner):

    root_dir = git.git_project_root()
    save_dir = os.getcwd()
    os.chdir(root_dir)

    root_name = os.path.basename(root_dir)
    branch_name = git.get_local_branch().replace('/', '_')
    timestamp = time.strftime('%y%m%d-%H%M%S')
    output_name = '-'.join([timestamp, root_name, branch_name])
    output_dir = os.path.join(runner.cmdargs.output, output_name)
    zip_name = 'changed-and-new.zip' if runner.cmdargs.all else 'changed.zip'
    zip_path = os.path.join(output_dir, zip_name)
    zip_path_abs = os.path.realpath(zip_path)
    diff_name = 'patch.diff'
    diff_path = os.path.join(output_dir, diff_name)
    diff_path_abs = os.path.realpath(diff_path)

    logger.info('Base directory (Git project root):', [root_dir])
    logger.info('Output directory:', [output_dir])

    if not runner.cmdargs.dryrun:
        os.makedirs(output_dir)

    try:

        file_paths = []

        logger.info('Archive: %s' % zip_name)

        for change in git.iter_changes():
            if change.flag.startswith('R'):
                file_paths.append(change.path2)
            elif change.flag != 'D' and change.path != zip_path_abs:
                if runner.cmdargs.all or change.flag != '??':
                    if runner.cmdargs.dryrun:
                        sys.stdout.write('+%s%s' % (change.path, os.linesep))
                    file_paths.append(change.path)

        if not file_paths:
            logger.info('Nothing to archive: %s' % root_name)

        if not runner.cmdargs.dryrun and file_paths:
            zip_file = zipfile.ZipFile(zip_path_abs, 'w', zipfile.ZIP_DEFLATED)
            for path in file_paths:
                if runner.cmdargs.verbose:
                    sys.stdout.write('+%s%s' % (path, os.linesep))
                zip_file.write(path)
            zip_file.close()

        logger.info('Patch diff: %s' % diff_name)

        if not runner.cmdargs.dryrun:
            with open(diff_path_abs, 'w') as diff_file:
                for line in run.pipe_cmd('git', 'diff'):
                    diff_file.write(line)
                    diff_file.write(os.linesep)

    finally:
        os.chdir(save_dir)


#===============================================================================
@cli.Command(
    name='new',
    description='Make a new branch.',
    args=[
        cli.String('ancestor', 'ancestor branch name', '-a', default=None),
        cli.String('branch', 'branch name'),
    ],
)
#===============================================================================
def _new(runner):
    folder = runner.cmdargs.branch
    runner.update(folder=folder)
    runner.shell('git fetch')
    runner.shell('git checkout master')
    runner.shell('git pull')
    git.create_branch(None,
                      runner.cmdargs.branch,
                      runner.cmdargs.ancestor,
                      create_remote=True,
                      dryrun=runner.cmdargs.dryrun,
                      verbose=runner.cmdargs.verbose)


#===============================================================================
@cli.Command(
    name='branches',
    description='List my branches and unmerged commits.',
)
#===============================================================================
def _branches(runner):
    info = git.get_info()
    for branch in git.iter_branches(user = info.user.name):
        sys.stdout.write('%s%s' % (branch, os.linesep))
        for commit in git.iter_unmerged_commits(branch):
            sys.stdout.write('   %s %s%s' % (commit.identifier, commit.comment, os.linesep))


#===============================================================================
@cli.Command(
    name='rename',
    description='Rename local and remote branch.',
    args=[
        cli.String('remotename', 'remote branch name, if different from local', '-r'),
        cli.String('branch', 'branch name'),
    ],
)
#===============================================================================
def _rename(runner):
    newlocal = runner.cmdargs.branch
    if runner.cmdargs.remotename:
        newremote = runner.cmdargs.remotename
    else:
        newremote = newlocal
    for s in run.pipe_cmd('git', 'status'):
        if s.startswith('# On branch '):
            oldbranch = s[12:]
            break
    else:
        logger.abort('Not in a GitHub-managed folder.')
    runner.update(newlocal=newlocal, newremote=newremote, oldbranch=oldbranch)
    runner.shell('git branch -m %(oldbranch)s %(newlocal)s')
    runner.shell('git push origin %(newremote)s')
    runner.shell('git branch --set-upstream %(newlocal)s origin/%(newremote)s')


#===============================================================================
@cli.Command(
    name='review',
    description='Submit a pull request for review.',
    args=[
        cli.String('title', 'pull request title'),
    ],
)
#===============================================================================
def _review(runner):
    tracking_branch = git.get_tracking_branch()
    branch = tracking_branch.split('/')[1]
    if not utility.find_executable('hub'):
        logger.abort('The hub command must be installed. (http://defunkt.io/hub/)',
                     'OS X Homebrew command: brew install hub')
    runner.shell('hub pull-request "%s" -b %s' % (runner.cmdargs.title, branch))


#===============================================================================
@cli.Command(
    name='url',
    description='Display the repository URL.',
    args=[
    ],
)
#===============================================================================
def _url(runner):
    print git.get_repository_url()


#===============================================================================
@cli.Command(
    name='quick_status',
    description='Display quick status, e.g. for bash PS1 prompt.',
)
#===============================================================================
def _quick_status(runner):
    root = git.find_branch_root()


#===============================================================================
if __name__ == '__main__':
#===============================================================================
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)

