#!/usr/bin/env python
#===============================================================================
#===============================================================================
# TZAR - simple archiving front end
#
# Supports multiple archivers, e.g. gzip, bzip2, zip, xz, and p7zip.
# Minimizes command line options by optimizing for simple local archival
# needs. E.g. there is no need to specify output file names. Uses pv for
# progress display when available. Substitutes faster archivers like
# pigz, lbzip2, and pbzip2 when available.
#===============================================================================
#===============================================================================


import sys
import os
import re
from time import strftime
from glob import glob

from lib import import_python_misc
import python_misc.cli as cli
import python_misc.logger as logger
import python_misc.run as run
import python_misc.utility as utility


#=== Non-configurable globals ==================================================

PROGRAM_DIR, PROGRAM_NAME = os.path.split(os.path.realpath(sys.argv[0]))

RC_NAME = '.%(PROGRAM_NAME)src' % globals()

# The platforms where "cp" doesn't support -a
#TODO: Add others (e.g. bsd?), even better - switch to shutil.
SIMPLE_CP_PLATFORMS = ['darwin']

# Display progress with "pv", if available.
PV_AVAILABLE = utility.find_executable('pv')

ARCHIVE_NAME_GLOB = '"%s"-[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]*'

TARBALL_TRAILER_RE = re.compile('^[.]%s/(.*)-([0-9]+-[0-9]+)([.]tar)?[.](gz|bz2)$'
                                    % PROGRAM_NAME)

NUMBER_WITH_DEFAULT_RE = re.compile('^[0-9]*$')

# Default for the overrideable output directory name.
DEFAULT_OUTPUT_DIRECTORY = '.%s' % PROGRAM_NAME

# Filespecs for --ignore-obj option exclusions.
DEFAULT_BINARY_PATTERNS = [
    '*.o',
    '*.so',
    '*.so.*',
    '*.co',
    '*.pyc',
    '*.pyd',
    '*.Plo',
    '*.la',
    '*.lai',
    '*.lo',
    '*.a',
    '*.dll',
    '*.DLL',
    '*.exe',
    '*.EXE',
    '*.lib',
    '*.LIB',
    '*.dylib',
    '*.jnilib',
    '*.jar',
    '*.deb',
    '*.rpm',
    '*.zip',
    '*.ZIP',
    '*.gz',
    '*.tgz',
    '*.bz2',
    '*.xz',
    '*.sym',
    '*.bin',
    '*/tags',
]

# Subdirectories ignored for --ignore-vcs option.
DEFAULT_VCS_DIRECTORIES = [
    '.svn',
    '.cvs',
    '.git',
]

DEFAULT_EXCLUDE_OTHER_PATTERNS = []

DEFAULT_EXCLUDE_BINARIES = False

DEFAULT_EXCLUDE_VCS = False

# Platform-specific copy command.
DEFAULT_COPY_COMMAND = 'cp -Rpv' if sys.platform in SIMPLE_CP_PLATFORMS else 'cp -av'

# Use "pigz" for gzip compression, if available.
DEFAULT_REPLACEMENT_GZIP = utility.find_executable('pigzx')

# Use "pbzip2" or "lbzip2" for bzip2 compression, if available.
DEFAULT_REPLACEMENT_BZIP2 = utility.find_executable('pbzip2', 'lbzip2')

# Common command line options and arguments for archiving
def get_archive_cli_args():
    return [
        cli.Boolean('delete', 'delete files after archiving',
                   '-d', '--delete', default=False),
        cli.Boolean('ignoreobj', 'ignore %s' % ' '.join(CONFIG.BINARY_PATTERNS),
                   '--ignore-obj', default=False),
        cli.Boolean('ignorevcs', 'ignore %s subdirectories' % ' '.join(CONFIG.VCS_DIRECTORIES),
                   '--ignore-vcs', default=False),
        cli.Boolean('noprogress', 'disable progress meter',
                   '--no-progress', default=False),
        cli.String('outputdir', 'output directory',
                   '-o', '--output-dir'),
        cli.String('path', 'path(s) to archive', nargs='+'),
    ]


#=== Configuration dictionary with pseudo-attributes ===========================

class ConfigDict(dict):

    def __init__(self, **kwargs):
        dict.__init__(self, **kwargs)

    def __getattr__(self, name):
        return self.get(name, None)

CONFIG = ConfigDict(
    BINARY_PATTERNS=DEFAULT_BINARY_PATTERNS,
    COPY_COMMAND=DEFAULT_COPY_COMMAND,
    EXCLUDE_BINARIES=DEFAULT_EXCLUDE_BINARIES,
    EXCLUDE_OTHER_PATTERNS=DEFAULT_EXCLUDE_OTHER_PATTERNS,
    EXCLUDE_VCS=DEFAULT_EXCLUDE_VCS,
    OUTPUT_DIRECTORY='.%s' % PROGRAM_NAME,
    REPLACEMENT_GZIP=DEFAULT_REPLACEMENT_GZIP,
    REPLACEMENT_BZIP2=DEFAULT_REPLACEMENT_BZIP2,
    VCS_DIRECTORIES=DEFAULT_VCS_DIRECTORIES,
)

CONFIG_HELP = dict(
    BINARY_PATTERNS='Binary file wildcard patterns that are optionally ignored.',
    COPY_COMMAND='Command used for file copy operations.',
    EXCLUDE_BINARIES='Exclude binary files if True.',
    EXCLUDE_OTHER_PATTERNS='Wildcard patterns for other excluded files.',
    EXCLUDE_VCS='Exclude VCS directories if True.',
    OUTPUT_DIRECTORY='Output subdirectory name.',
    REPLACEMENT_GZIP='Compatible gzip replacement. By default pigzx is used when available.',
    REPLACEMENT_BZIP2='Compatible bzip2 replacement. By default pbzip2 or lbzip2 are used when available.',
    VCS_DIRECTORIES='VCS directory names that are optionally ignored.',
)


#===============================================================================

def quote_args(*args):
    return '"%s"' % ''.join([s.replace('"', '\\"') for s in args])


#===============================================================================

class Runner(object):
    def __init__(self, echo=False, dryrun=False):
        self.echo   = echo
        self.dryrun = dryrun
        self.cmds   = []
        self.cur    = 0
    def append(self, *cmd):
        self.cmds.append(list(cmd))
        self.cur = len(self.cmds) - 1
        return self.cur
    def insert(self, *cmd):
        self.cmds.insert(self.cur, list(cmd))
        return self.cur
    def rewind(self, pos = 0):
        assert pos >= 0 and pos < len(self.cmds)
        self.cur = pos
    def add_args(self, *args):
        assert self.cur >= 0 and self.cur < len(self.cmds)
        self.cmds[self.cur].extend(args)
    def run(self):
        for cmd in self.cmds:
            scmd = ' '.join(cmd)
            if self.dryrun:
                logger.info('>>> %s' % scmd)
            elif self.echo:
                logger.info(scmd)
            if not self.dryrun:
                os.system(scmd)


#===============================================================================

class ArchiveItem(object):

    def __init__(self, path,
                 dryrun=False,
                 pause=False,
                 verbose=False,
                 delete=False,
                 excludes=[],
                 ignoreobj=False,
                 ignorevcs=False,
                 noprogress=False,
                 outputdir=None):
        self.path        = path
        self.dryrun      = dryrun
        self.pause       = pause
        self.verbose     = verbose
        self.delete      = delete
        self.excludes    = excludes
        self.ignoreobj   = ignoreobj
        self.ignorevcs   = ignorevcs
        self.outputdir   = outputdir if outputdir else CONFIG.OUTPUT_DIRECTORY
        self.timestamp   = get_timestamp()
        self.name        = '%s-%s' % (self.path.replace('/', '_'), self.timestamp)
        self.archive     = os.path.join(self.outputdir, self.name)
        self.compression = None
        self.noprogress  = noprogress
        self.check_output_directory()
        if CONFIG.EXCLUDE_BINARIES:
            self.ignoreobj = True
        if CONFIG.EXCLUDE_VCS:
            self.ignorevcs = True

    def check_output_directory(self):
        if not os.path.isdir(self.outputdir):
            if os.path.exists(self.outputdir):
                logger.abort('"%s" exists and is not a directory' % self.outputdir)
            logger.info('Creating %s...' % self.outputdir)
            try:
                os.mkdir(self.outputdir)
            except (IOError, OSError), e:
                logger.abort('Unable to create output directory', self.outputdir, e)


#===============================================================================

class ArchiveTarball(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.tar':
            return None
        if m.group(4) == 'bz2':
            return ArchiveTarball(path, 'bzip2', **kwargs)
        if m.group(4) == 'xz':
            return ArchiveTarball(path, 'xz', **kwargs)
        return ArchiveTarball(path, 'gzip', **kwargs)

    def __init__(self, path, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression
        if self.compression == 'bzip2':
            self.tar_compression_options = 'j'
            self.external_compression_program = CONFIG.REPLACEMENT_BZIP2
            self.tar_extension = '.tar.bz2'
        elif self.compression == 'xz':
            if  'XZ_OPTS' in os.environ:
                os.environ['XZ_OPTS'] = '%s --threads=0' % os.environ['XZ_OPTS']
            else:
                os.environ['XZ_OPTS'] = '--threads=0'
            self.tar_compression_options = 'J'
            self.external_compression_program = None
            self.tar_extension = '.tar.xz'
        else:
            self.tar_compression_options = 'z'
            self.external_compression_program = CONFIG.REPLACEMENT_GZIP
            self.tar_extension = '.tar.gz'
        if PV_AVAILABLE and not self.noprogress:
            self.tar_create_options = ['-c%s' % self.tar_compression_options]
        else:
            self.tar_create_options = ['-cv%s' % self.tar_compression_options]
        if self.external_compression_program:
            self.tar_create_options.extend(['--use-compress-program',
                                            self.external_compression_program])
        self.tar_create_options.append('-f')
        self.tar_restore_options = '-%s%s%s' % ('x', self.tar_compression_options, 'pf')
        self.tar_compare_options = '-%s%s%s' % ('d', self.tar_compression_options, 'f')

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        runner.append('tar')
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.BINARY_PATTERNS:
                runner.add_args('--exclude', quote_args(pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.VCS_DIRECTORIES:
                runner.add_args('--exclude', quote_args('*/', pat, '/*'))
        # Add other exclusions?
        for exclude in self.excludes:
            runner.add_args('--exclude', quote_args(exclude))
        # Add tar options based on compression type
        runner.add_args(*self.tar_create_options)
        # Complete command line for running with or without pv
        if PV_AVAILABLE and not self.noprogress:
            runner.add_args('-',
                            quote_args(self.path),
                            '|',
                            'pv',
                            '-rbt',
                            '>',
                            quote_args(self.archive, self.tar_extension))
            runner.insert('echo',
                          quote_args('Creating "', self.archive, self.tar_extension, '"...'))
        else:
            runner.add_args(quote_args(self.archive, self.tar_extension), quote_args(self.path))
        # Delete original when done?
        if self.delete:
            runner.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        runner.run()

    def restore(self):
        dir = utility.get_versioned_path(os.path.basename(self.path)[:-len(self.tar_extension)])
        os.mkdir(dir)
        logger.info('Restoring to "%s"...' % dir)
        os.system('tar %s "%s" --strip-components 1 -C "%s"'
                        % (self.tar_restore_options, self.path, dir))

    def compare(self):
        os.system('tar %s "%s"' % (self.tar_compare_options))


#===============================================================================

class ArchiveZip(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.zip':
            return None
        return ArchiveZip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        runner.append('zip', '-r', '--symlinks')
        runner.add_args(quote_args(self.archive, '.zip'), quote_args(self.path))
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.BINARY_PATTERNS:
                runner.add_args('--exclude', quote_args(pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.VCS_DIRECTORIES:
                runner.add_args('--exclude', quote_args('*/', pat, '/*'))
        # Add other exclusions?
        for exclude in self.excludes:
            runner.add_args('--exclude', quote_args(exclude))
        # Delete original when done?
        if self.delete:
            runner.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        runner.run()

    def restore(self):
        logger.abort('Restore is not yet implemented for zip compression.')

    def compare(self):
        logger.abort('Compare is not yet implemented for zip compression.')


#===============================================================================

class ArchiveP7Zip(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.7z':
            return None
        return ArchiveP7Zip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        runner.append('7z', 'a')
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.BINARY_PATTERNS:
                runner.add_args(quote_args('-xr!', pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.VCS_DIRECTORIES:
                runner.add_args(quote_args('-xr!', pat, '/*'))
        runner.add_args(quote_args(self.archive, '.7z'), quote_args(self.path))
        # Delete original when done?
        if self.delete:
            runner.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        runner.run()

    def restore(self):
        logger.abort('Restore is not yet implemented for p7zip compression.')

    def compare(self):
        logger.abort('Compare is not yet implemented for p7zip compression.')


#===============================================================================

class ArchiveCompressedFile(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        ext = os.path.splitext(path)[1]
        if m is not None:
            return None
        if ext == '.gz':
            return ArchiveCompressedFile(path, 'gzip', **kwargs)
        if ext == '.bz2':
            return ArchiveCompressedFile(path, 'bzip2', **kwargs)
        if ext == '.xz':
            return ArchiveCompressedFile(path, 'xz', **kwargs)
        return None

    def __init__(self, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        # Move or copy the file to the archive subdirectory
        if self.delete:
            runner.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            runner.append(CONFIG.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        # Then compress it
        runner.append(self.compression, quote_args(self.archive))
        # Run command batch
        runner.run()

    def restore(self):
        pass

    def compare(self):
        pass


#===============================================================================

class ArchiveDirectory(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        if not os.path.isdir(path):
            return None
        return ArchiveDirectory(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        if self.delete:
            runner.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            runner.append(CONFIG.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        runner.run()

    def restore(self):
        target = utility.get_versioned_path(self.path)
        runner = Runner(dryrun=self.dryrun)
        runner.append(CONFIG.COPY_COMMAND, quote_args(self.path), quote_args(target))
        logger.info('Restoring to "%s"...' % target)
        runner.run()


#===============================================================================

class ArchiveFile(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is not None or os.path.isdir(path):
            return None
        return ArchiveFile(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        runner = Runner(dryrun=self.dryrun)
        if self.delete:
            runner.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            runner.append(CONFIG.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        runner.run()

    def restore(self, path):
        target = utility.get_versioned_path(self.path)
        runner = Runner(dryrun=self.dryrun)
        runner.append(CONFIG.COPY_COMMAND, quote_args(self.path), quote_args(target))
        logger.info('Restoring to "%s"...' % target)
        runner.run()


#===============================================================================

class FMFactory(object):
    @staticmethod
    def forPath(path, **kwargs):
        for fmCls in (
                ArchiveTarball,
                ArchiveZip,
                ArchiveP7Zip,
                ArchiveDirectory,
                ArchiveFile,
                ArchiveCompressedFile
        ):
            fm = fmCls.forPath(path, **kwargs)
            if fm:
                return fm
        logger.abort('"%s" is not a supported type' % path)


#===============================================================================

def choose(name, **kwargs):

    if not os.path.isdir(CONFIG.OUTPUT_DIRECTORY):
        logger.abort('No %s directory exists' % CONFIG.OUTPUT_DIRECTORY)
    if name[-1] == '/':
        name = name[:-1]
    pat = os.path.join(CONFIG.OUTPUT_DIRECTORY, ARCHIVE_NAME_GLOB % name)
    archives = []
    for a in os.popen('ls %s' % pat):
        archives.insert(0, a.strip())
    if len(archives) == 0:
        logger.abort('No archives found')
    logger.info('Newest archive is at the top.  Empty input or zero response cancels the action.')
    for i in range(len(archives)):
        logger.info('%d) %s' % (i+1, archives[i]))
    logger.info('')
    path = None
    while path is None:
        i = int(utility.prompt_re('Select archive (1-n [none])', NUMBER_WITH_DEFAULT_RE, '0'))
        if i <= 0:
            logger.abort('Canceled')
        if i-1 < len(archives):
            path = archives[i-1]
        else:
            logger.error('bad index %d' % i)
    return (path, FMFactory.forPath(path, **kwargs))


#===============================================================================

def get_timestamp():
    return strftime('%y%m%d-%H%M%S')


#===============================================================================

def cmdargs_to_kwargs(cmdargs):
    return dict(
        dryrun=cmdargs.dryrun,
        pause=cmdargs.pause,
        verbose=cmdargs.verbose,
        delete=cmdargs.delete,
        ignoreobj=cmdargs.ignoreobj,
        ignorevcs=cmdargs.ignorevcs,
        noprogress=cmdargs.noprogress,
        outputdir=cmdargs.outputdir
    )

#===============================================================================
@cli.Command(
    name='put',
    description='Archive using a straight copy.',
    args=get_archive_cli_args()
)
#===============================================================================
def _put(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = FMFactory.forPath(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='gz',
    description='Archive with gzip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _gzip(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "gzip", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='bz2',
    description='Archive with bzip2 compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _bzip2(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "bzip2", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='xz',
    description='Archive with xz compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _xz(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "xz", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='zip',
    description='Archive with zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _zip(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveZip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='7z',
    description='Archive with p7zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _p7zip(runner):
    read_configs()
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveP7Zip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='get',
    description='Restore from archive.',
    args=[
        cli.String('path', 'path(s) to restore', nargs='+'),
    ]
)
#===============================================================================
def _get(runner):
    read_configs()
    for name in files:
        (path, fm) = choose(name, **cmdargs_to_kwargs(runner.cmdargs))
        fm.restore(path)


#===============================================================================
@cli.Command(
    name='cmp',
    description='Compare with archive.',
    args=[
        cli.String('path', 'path(s) to compare', nargs='+'),
    ]
)
#===============================================================================
def _compare(runner):
    read_configs()
    for name in files:
        (path, fm) = choose(name, **cmdargs_to_kwargs(runner.cmdargs))
        fm.compare(path)


#===============================================================================
@cli.Command(
    name='generate-rc',
    description='Generate sample RC file to working directory.',
)
#===============================================================================
def _generate_rc(runner):
    try:
        if os.path.exists(RC_NAME):
            logger.abort('RC file already exists: %(RC_NAME)s' % globals())
        with open(RC_NAME, 'w') as f:
            f.write('''\
# Un-comment and edit below to change defaults.
# Note that it uses Python syntax, e.g. for strings, lists, assignments and comments.
''')
            for key in sorted(CONFIG.keys()):
                f.write('\n')
                if key in CONFIG_HELP:
                    f.write('# %s\n' % CONFIG_HELP[key])
                f.write('#%s\n' % name_value_dump_string(key, CONFIG[key]))
        logger.info('RC file written: %(RC_NAME)s' % globals())
    except (IOError, OSError), e:
        logger.abort('Unable to save generated RC file: %(RC_NAME)s' % globals(), e)


#===============================================================================
def read_config(directory):
#===============================================================================
    path = os.path.expanduser(os.path.expandvars(os.path.join(directory, RC_NAME)))
    if not os.path.isfile(path):
        return
    try:
        logger.verbose_info('Reading configuration file: %(path)s' % locals())
        execfile(path, dict(), CONFIG)
    except Exception, e:
        logger.abort('Error reading configuration file: %(path)s' % locals(), e)


#===============================================================================
def read_configs(*directories):
#===============================================================================
    for directory in ['~', '.'] + list(directories):
        read_config(directory)
    if logger.is_verbose():
        dump_config()


#===============================================================================
def name_value_dump_string(name, value):
#===============================================================================
    quote = "'" if type(value) is str else ''
    return '%(name)s = %(quote)s%(value)s%(quote)s' % locals()


#===============================================================================
def dump_config():
#===============================================================================
    logger.verbose_info('=== Configuration ===')
    for key in sorted(CONFIG.keys()):
        logger.verbose_info(name_value_dump_string(key, CONFIG[key]))


#===============================================================================
def main():
#===============================================================================
    parser = cli.Parser(
        'Simple archiver front end.',
        cli.Boolean('dryrun', "perform dry run - display, but don't execute commands",
                    '-n', '--dry-run'),
        cli.Boolean('pause', "pause before executing each command",
                    '-p', '--pause'),
        cli.Boolean('verbose', "enable verbose messages",
                    '-v', '--verbose')
    )
    parser.parse()
    logger.set_verbose(parser.cmdargs.verbose)
    parser.run()


#===============================================================================
if __name__ == '__main__':
#===============================================================================
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
