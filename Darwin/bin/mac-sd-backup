#!/usr/bin/env python3
# Copyright 2021 Steven Cooper
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
import argparse
import subprocess
import plistlib
import re
import time
from dataclasses import dataclass
from typing import List, Optional

COMPRESSION = 'gz'
COMPRESSION_PROGRAM = 'gzip'
NAME_REGEX = re.compile('^\w+$')


def abort(message: str):
    """Display fatal error and quit."""
    sys.stderr.write(f'FATAL: {message}\n')
    sys.exit(1)


def find_executable(*names: str) -> Optional[str]:
    """
    Find an executable program in the shell PATH.

    If multiple names are specified return the first one found in the path.

    Return path to first name found in PATH.
    """
    env_path = os.environ['PATH']
    for name in names:
        path = find_in_path(env_path, name, executable=True)
        if path:
            return os.path.realpath(path)
    return None


# noinspection DuplicatedCode
def find_in_path(path: str, name: str, executable: bool = False) -> Optional[str]:
    """
    Find a file in a shell-compatible path string.

    Return path to name if found in path, or None if not found.  Require
    executable if executable is True.
    """
    for directory in path.split(os.pathsep):
        chk_path = os.path.join(directory, name)
        if executable:
            if sys.platform in ('cygwin', 'windows'):
                for ext in ('', '.exe', '.bat', '.cmd', '.com'):
                    if os.path.exists(chk_path + ext):
                        return chk_path
            elif os.path.exists(chk_path) and (os.stat(chk_path)[0] & 0o111) != 0:
                return chk_path
        elif os.path.exists(chk_path):
            return chk_path
    return None


@dataclass
class Disk:
    device: str
    size: int
    partition_names: List[str]

    def __post_init__(self):
        self.size_gib = self.size / 1000000000
        self.size_g = self.size / 1073741824


def get_disks() -> List[Disk]:
    """Get disk data."""
    proc = subprocess.run(['diskutil', 'list', '-plist'],
                          capture_output=True, check=False)
    if proc.returncode != 0:
        abort(f'Unable to get disk data.')
    disks: List[Disk] = []
    disks_data = plistlib.loads(proc.stdout)
    for disk_item in disks_data['AllDisksAndPartitions']:
        partitions = disk_item.get('Partitions', [])
        volume_names = [part_item.get('VolumeName', '(no name)') for part_item in partitions]
        disks.append(Disk(f'/dev/{disk_item["DeviceIdentifier"]}',
                          disk_item['Size'],
                          volume_names))
    return disks


def main():
    """Parse the command line and perform disk checks."""
    parser = argparse.ArgumentParser(description='Mac SD card backup.')
    parser.add_argument('NAME', help='base backup name (date/time added)')
    parser.add_argument('FOLDER', help='target folder')
    args = parser.parse_args()
    if not NAME_REGEX.match(args.NAME):
        abort(f'Bad name "{args.NAME}".')
    if not os.path.isdir(args.FOLDER):
        abort(f'Bad target folder "{args.FOLDER}".')
    disks = get_disks()
    for idx, disk in enumerate(disks):
        print(f'{idx + 1}) {disk.device:10}  {disk.size_gib:8.1f} GiB  {" ".join(disk.partition_names)}')
    print('')
    choice = -1
    while choice < 1 or choice > len(disks):
        try:
            choice = int(input(f'Source device (1-{len(disks)})? '))
        except ValueError:
            choice = -1
    disk = disks[choice-1]
    print('')
    print(f'You have chosen: {disk.device} ({disk.size_gib:.1f} GiB)')
    print('')
    choice = ''
    while choice not in {'yes', 'no'}:
        choice = input('Is that correct (yes|no)? ')
    print('')
    if choice != 'yes':
        abort('Cancel.')
    timestamp = time.strftime('%Y%m%d_%H%M%S')
    pv_path = find_executable('pv')
    target = os.path.join(args.FOLDER, f'{args.NAME}_{timestamp}.dmg.{COMPRESSION}')
    target_tmp = f'{target}.tmp'
    if pv_path:
        command = f'sudo dd bs=4M if={disk.device} | pv -s {disk.size} -rebt | {COMPRESSION_PROGRAM} - > "{target_tmp}"'
    else:
        print('Consider installing pv (brew install pv) for more useful progress output.')
        command = f'sudo dd bs=4M if={disk.device} | {COMPRESSION_PROGRAM} - > "{target_tmp}"'
    # Use sudo for echo so that the password prompt won't happen before I/O piping starts.
    os.system('sudo echo "Backing up {disk.device} to {target}..."')
    print(f'command: {command}')
    try:
        if os.system(command) == 0:
            os.rename(target_tmp, target)
    finally:
        if os.path.exists(target_tmp):
            os.remove(target_tmp)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('')
