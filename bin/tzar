#!/usr/bin/env python
# Copyright 2016 Steven Cooper
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#===============================================================================
#===============================================================================
# TZAR - simple archiving front end
#
# Features:
#
#   Multiple archive formats:
#
#     - gzip    standard with high speed and less compression
#     - bzip2   standard with better compression than gzip, but slower
#     - xz      newer standard with better compression than bzip2, but slower
#     - zip     multi-platform format with good speed/compression balance
#     - p7zip   slower high compression format
#     - lzip    another slower high compression format
#     - put     straight file copy
#
#   Performance:
#
#     Performance is determined by the external command line tool that is used
#     for a particular format, but it takes advantage of faster multi-threaded
#     archiving tools like pigz, pxz, lbzip2, and pbzip2 when available.
#
#   Operations:
#
#     - compress using format choice
#     - compare to archive (limited)
#     - restore from archive (limited)
#     - generate a configuration file template
#
#   Usability:
#
#     - Provides a simple command line interface, e.g. that allows creating an
#       archive without specifying an output file.
#     - Uses pv when it is available to display a real-time i/o progress meter.
#     - Supports per-location and global configuration files to fine-tune
#       default options for different directories, e.g. to always exclude local
#       temporary files from the archive.
#===============================================================================
#===============================================================================


import sys
import os
import re
from time import strftime
from glob import glob

from lib import import_scriptbase
from scriptbase import cli
from scriptbase import console
from scriptbase.configuration import ConfigSpec, Config
from scriptbase import disk
from scriptbase import shell


#=== Non-configurable globals ==================================================

PROGRAM_DIR, PROGRAM_NAME = os.path.split(os.path.realpath(sys.argv[0]))

# The platforms where "cp" doesn't support -a
#TODO: Add others (e.g. bsd?), even better - switch to shutil.
SIMPLE_CP_PLATFORMS = ['darwin']

# Display progress with "pv", if available.
PV_AVAILABLE = shell.find_executable('pv')

ARCHIVE_NAME_GLOB = '"%s"-[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]*'

TARBALL_TRAILER_RE = re.compile('^[.]%s/(.*)-([0-9]+-[0-9]+)([.]tar)?[.](gz|bz2)$'
                                    % PROGRAM_NAME)

NUMBER_WITH_DEFAULT_RE = re.compile('^[0-9]*$')

# Common command line options and arguments for archiving
def get_archive_cli_args():
    return [
        cli.Boolean('delete', 'delete files after archiving',
                   '-d', '--delete', default=False),
        cli.Boolean('ignoreobj', 'ignore %s' % ' '.join(CONFIG.data.BINARY_PATTERNS),
                   '--ignore-obj', default=False),
        cli.Boolean('ignorevcs', 'ignore %s subdirectories' % ' '.join(CONFIG.data.VCS_DIRECTORIES),
                   '--ignore-vcs', default=False),
        cli.Boolean('noprogress', 'disable progress meter',
                   '--no-progress', default=False),
        cli.String('outputdir', 'output directory',
                   '-o', '--output-dir'),
        cli.String('path', 'path(s) to archive', nargs='+'),
    ]


#=== Configuration dictionary with pseudo-attributes ===========================

CONFIG = Config('.%(PROGRAM_NAME)src' % globals(),
    ConfigSpec(
        'BINARY_PATTERNS',
        [
            '*.o',
            '*.so',
            '*.so.*',
            '*.co',
            '*.pyc',
            '*.pyd',
            '*.Plo',
            '*.la',
            '*.lai',
            '*.lo',
            '*.a',
            '*.dll',
            '*.DLL',
            '*.exe',
            '*.EXE',
            '*.lib',
            '*.LIB',
            '*.dylib',
            '*.jnilib',
            '*.jar',
            '*.deb',
            '*.rpm',
            '*.zip',
            '*.ZIP',
            '*.gz',
            '*.tgz',
            '*.bz2',
            '*.xz',
            '*.lz',
            '*.sym',
            '*.bin',
            '*/tags',
        ],
        'Binary file wildcard patterns that are optionally ignored.'
    ),
    ConfigSpec(
        'COPY_COMMAND',
        'cp -Rpv' if sys.platform in SIMPLE_CP_PLATFORMS else 'cp -av',
        'Command used for file copy operations.'
    ),
    ConfigSpec(
        'EXCLUDE_BINARIES',
        False,
        'Exclude binary files if True.'
    ),
    ConfigSpec(
        'EXCLUDE_OTHER_PATTERNS',
        [],
        'Wildcard patterns for other excluded files.'
    ),
    ConfigSpec(
        'EXCLUDE_VCS',
        False,
        'Exclude VCS directories if True.'
    ),
    ConfigSpec(
        'OUTPUT_DIRECTORY',
        '.%s' % PROGRAM_NAME,
        'Output subdirectory name.'
    ),
    ConfigSpec(
        'REPLACEMENT_GZIP',
        shell.find_executable('pigz'),
        'Compatible gzip replacement. By default pigz is used when available.'
    ),
    ConfigSpec(
        'REPLACEMENT_BZIP2',
        shell.find_executable('pbzip2', 'lbzip2'),
        'Compatible bzip2 replacement. By default pbzip2 or lbzip2 are used when available.'
    ),
    ConfigSpec(
        'REPLACEMENT_XZ',
        shell.find_executable('pxz', 'pixz'),
        'Compatible xz replacement. By default pxz or pixz are used when available.'
    ),
    ConfigSpec(
        'REPLACEMENT_LZIP',
        shell.find_executable('plzip'),
        'Compatible lzip replacement. By default plzip is used when available.'
    ),
    ConfigSpec(
        'VCS_DIRECTORIES',
        [ '.svn', '.cvs', '.git' ],
        'VCS directory names that are optionally ignored.'
    ),
)


#===============================================================================

def quote_args(*args):
    return '"%s"' % ''.join([s.replace('"', '\\"') for s in args])


#===============================================================================

class CommandBatch(object):
    def __init__(self, echo=False, dryrun=False):
        self.echo   = echo
        self.dryrun = dryrun
        self.cmds   = []
        self.cur    = 0
    def append(self, *cmd):
        self.cmds.append(list(cmd))
        self.cur = len(self.cmds) - 1
        return self.cur
    def insert(self, *cmd):
        self.cmds.insert(self.cur, list(cmd))
        return self.cur
    def rewind(self, pos = 0):
        assert pos >= 0 and pos < len(self.cmds)
        self.cur = pos
    def add_args(self, *args):
        assert self.cur >= 0 and self.cur < len(self.cmds)
        self.cmds[self.cur].extend(args)
    def run(self):
        for cmd in self.cmds:
            scmd = ' '.join(cmd)
            if self.dryrun:
                console.info('>>> %s' % scmd)
            elif self.echo:
                console.info(scmd)
            if not self.dryrun:
                os.system(scmd)


#===============================================================================

class ArchiveItem(object):

    def __init__(self, path,
                 dryrun=False,
                 pause=False,
                 verbose=False,
                 delete=False,
                 excludes=[],
                 ignoreobj=False,
                 ignorevcs=False,
                 noprogress=False,
                 outputdir=None):
        self.path        = path
        self.dryrun      = dryrun
        self.pause       = pause
        self.verbose     = verbose
        self.delete      = delete
        self.excludes    = excludes
        self.ignoreobj   = ignoreobj
        self.ignorevcs   = ignorevcs
        self.outputdir   = outputdir if outputdir else CONFIG.data.OUTPUT_DIRECTORY
        self.timestamp   = get_timestamp()
        self.name        = '%s-%s' % (self.path.replace('/', '_'), self.timestamp)
        self.archive     = os.path.join(self.outputdir, self.name)
        self.compression = None
        self.noprogress  = noprogress
        self.check_output_directory()
        if CONFIG.data.EXCLUDE_BINARIES:
            self.ignoreobj = True
        if CONFIG.data.EXCLUDE_VCS:
            self.ignorevcs = True
        self.excludes.extend(CONFIG.data.EXCLUDE_OTHER_PATTERNS)

    def check_output_directory(self):
        if not os.path.isdir(self.outputdir):
            if os.path.exists(self.outputdir):
                console.abort('"%s" exists and is not a directory' % self.outputdir)
            console.info('Creating %s...' % self.outputdir)
            try:
                os.mkdir(self.outputdir)
            except (IOError, OSError) as e:
                console.abort('Unable to create output directory', self.outputdir, e)


#===============================================================================

class ArchiveTarball(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.tar':
            return None
        if m.group(4) == 'bz2':
            return ArchiveTarball(path, 'bzip2', **kwargs)
        if m.group(4) == 'xz':
            return ArchiveTarball(path, 'xz', **kwargs)
        if m.group(4) == 'lz':
            return ArchiveTarball(path, 'lzip', **kwargs)
        return ArchiveTarball(path, 'gzip', **kwargs)

    def __init__(self, path, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression
        if self.compression == 'bzip2':
            self.external_compression_program = CONFIG.data.REPLACEMENT_BZIP2
            self.tar_compression_options = 'j'
            self.tar_extension = '.tar.bz2'
        elif self.compression == 'xz':
            if  'XZ_OPTS' in os.environ:
                os.environ['XZ_OPTS'] = '%s --threads=0' % os.environ['XZ_OPTS']
            else:
                os.environ['XZ_OPTS'] = '--threads=0'
            self.tar_compression_options = 'J'
            self.external_compression_program = CONFIG.data.REPLACEMENT_XZ
            self.tar_extension = '.tar.xz'
        elif self.compression == 'lzip':
            if  'LZ_OPTS' in os.environ:
                os.environ['LZ_OPTS'] = '%s --threads=0' % os.environ['LZ_OPTS']
            else:
                os.environ['LZ_OPTS'] = '--threads=0'
            self.tar_compression_options = None
            self.external_compression_program = CONFIG.data.REPLACEMENT_LZIP
            self.tar_extension = '.tar.lz'
        else:
            self.tar_compression_options = 'z'
            self.external_compression_program = CONFIG.data.REPLACEMENT_GZIP
            self.tar_extension = '.tar.gz'
        verbose_option = 'v' if not PV_AVAILABLE or self.noprogress else ''
        self.tar_create_options = []
        if self.external_compression_program:
            compression_options = ''
            self.tar_create_options.extend(['--use-compress-program',
                                            self.external_compression_program])
        else:
            compression_options = self.tar_compression_options
        self.tar_create_options.append('-c%s%s' % (verbose_option, compression_options))
        self.tar_create_options.append('-f')
        self.tar_restore_options = '-%s%s%s' % ('x', self.tar_compression_options, 'pf')
        self.tar_compare_options = '-%s%s%s' % ('d', self.tar_compression_options, 'f')

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        batch.append('tar')
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.data.BINARY_PATTERNS:
                batch.add_args('--exclude', quote_args(pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.data.VCS_DIRECTORIES:
                batch.add_args('--exclude', quote_args('*/', pat, '/*'))
        # Add other exclusions?
        for exclude in self.excludes:
            batch.add_args('--exclude', quote_args(exclude))
        # Add tar options based on compression type
        batch.add_args(*self.tar_create_options)
        # Complete command line for running with or without pv
        if PV_AVAILABLE and not self.noprogress:
            batch.add_args('-',
                            quote_args(self.path),
                            '|',
                            'pv',
                            '-rbt',
                            '>',
                            quote_args(self.archive, self.tar_extension))
            batch.insert('echo',
                          quote_args('Creating "', self.archive, self.tar_extension, '"...'))
        else:
            batch.add_args(quote_args(self.archive, self.tar_extension), quote_args(self.path))
        # Delete original when done?
        if self.delete:
            batch.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        batch.run()

    def restore(self):
        dir = disk.get_versioned_path(os.path.basename(self.path)[:-len(self.tar_extension)])
        os.mkdir(dir)
        console.info('Restoring to "%s"...' % dir)
        os.system('tar %s "%s" --strip-components 1 -C "%s"'
                        % (self.tar_restore_options, self.path, dir))

    def compare(self):
        os.system('tar %s "%s"' % (self.tar_compare_options))


#===============================================================================

class ArchiveZip(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.zip':
            return None
        return ArchiveZip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        batch.append('zip', '-r', '--symlinks')
        batch.add_args(quote_args(self.archive, '.zip'), quote_args(self.path))
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.data.BINARY_PATTERNS:
                batch.add_args('--exclude', quote_args(pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.data.VCS_DIRECTORIES:
                batch.add_args('--exclude', quote_args('*/', pat, '/*'))
        # Add other exclusions?
        for exclude in self.excludes:
            batch.add_args('--exclude', quote_args(exclude))
        # Delete original when done?
        if self.delete:
            batch.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        batch.run()

    def restore(self):
        console.abort('Restore is not yet implemented for zip compression.')

    def compare(self):
        console.abort('Compare is not yet implemented for zip compression.')


#===============================================================================

class ArchiveP7Zip(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.7z':
            return None
        return ArchiveP7Zip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        batch.append('7za', 'a')
        # Add object file exclusions?
        if self.ignoreobj:
            for pat in CONFIG.data.BINARY_PATTERNS:
                batch.add_args(quote_args('-xr!', pat))
        # Add VCS exclusions?
        if self.ignorevcs:
            for pat in CONFIG.data.VCS_DIRECTORIES:
                batch.add_args(quote_args('-xr!', pat, '/*'))
        # Add other exclusions?
        for exclude in self.excludes:
            batch.add_args('-xr!%s' % quote_args(exclude))
        batch.add_args(quote_args(self.archive, '.7z'), quote_args(self.path))
        # Delete original when done?
        if self.delete:
            batch.append('rm', '-rvf', quote_args(self.path))
        # Run command batch
        batch.run()

    def restore(self):
        console.abort('Restore is not yet implemented for p7zip compression.')

    def compare(self):
        console.abort('Compare is not yet implemented for p7zip compression.')


#===============================================================================

class ArchiveCompressedFile(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        ext = os.path.splitext(path)[1]
        if m is not None:
            return None
        if ext == '.gz':
            return ArchiveCompressedFile(path, 'gzip', **kwargs)
        if ext == '.bz2':
            return ArchiveCompressedFile(path, 'bzip2', **kwargs)
        if ext == '.xz':
            return ArchiveCompressedFile(path, 'xz', **kwargs)
        if ext == '.lz':
            return ArchiveCompressedFile(path, 'lzip', **kwargs)
        return None

    def __init__(self, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        # Move or copy the file to the archive subdirectory
        if self.delete:
            batch.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            batch.append(CONFIG.data.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        # Then compress it
        batch.append(self.compression, quote_args(self.archive))
        # Run command batch
        batch.run()

    def restore(self):
        pass

    def compare(self):
        pass


#===============================================================================

class ArchiveDirectory(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        if not os.path.isdir(path):
            return None
        return ArchiveDirectory(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        if self.delete:
            batch.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            batch.append(CONFIG.data.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        batch.run()

    def restore(self):
        target = disk.get_versioned_path(self.path)
        batch = CommandBatch(dryrun=self.dryrun)
        batch.append(CONFIG.data.COPY_COMMAND, quote_args(self.path), quote_args(target))
        console.info('Restoring to "%s"...' % target)
        batch.run()


#===============================================================================

class ArchiveFile(ArchiveItem):

    @staticmethod
    def forPath(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is not None or os.path.isdir(path):
            return None
        return ArchiveFile(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def create(self):
        batch = CommandBatch(dryrun=self.dryrun)
        if self.delete:
            batch.append('mv', '-v', quote_args(self.path), quote_args(self.archive))
        else:
            batch.append(CONFIG.data.COPY_COMMAND, quote_args(self.path), quote_args(self.archive))
        batch.run()

    def restore(self, path):
        target = disk.get_versioned_path(self.path)
        batch = CommandBatch(dryrun=self.dryrun)
        batch.append(CONFIG.data.COPY_COMMAND, quote_args(self.path), quote_args(target))
        console.info('Restoring to "%s"...' % target)
        batch.run()


#===============================================================================

class FMFactory(object):
    @staticmethod
    def forPath(path, **kwargs):
        for fmCls in (
                ArchiveTarball,
                ArchiveZip,
                ArchiveP7Zip,
                ArchiveDirectory,
                ArchiveFile,
                ArchiveCompressedFile
        ):
            fm = fmCls.forPath(path, **kwargs)
            if fm:
                return fm
        console.abort('"%s" is not a supported type' % path)


#===============================================================================

def choose_archive(name, **kwargs):

    if not os.path.isdir(CONFIG.data.OUTPUT_DIRECTORY):
        console.abort('No %s directory exists' % CONFIG.data.OUTPUT_DIRECTORY)
    if name[-1] == '/':
        name = name[:-1]
    pat = os.path.join(CONFIG.data.OUTPUT_DIRECTORY, ARCHIVE_NAME_GLOB % name)
    archives = []
    for a in os.popen('ls %s' % pat):
        archives.insert(0, a.strip())
    if len(archives) == 0:
        console.abort('No archives found')
    console.info('Newest archive is at the top.  Empty input or zero response cancels the action.')
    for i in range(len(archives)):
        console.info('%d) %s' % (i+1, archives[i]))
    console.info('')
    path = None
    while path is None:
        i = int(console.prompt_re('Select archive (1-n [none])', NUMBER_WITH_DEFAULT_RE, '0'))
        if i <= 0:
            console.abort('Canceled')
        if i-1 < len(archives):
            path = archives[i-1]
        else:
            console.error('bad index %d' % i)
    return (path, FMFactory.forPath(path, **kwargs))


#===============================================================================

def get_timestamp():
    return strftime('%y%m%d-%H%M%S')


#===============================================================================

def cmdargs_to_kwargs(cmdargs):
    return dict(
        dryrun=cmdargs.dryrun,
        pause=cmdargs.pause,
        verbose=cmdargs.verbose,
        delete=cmdargs.delete,
        ignoreobj=cmdargs.ignoreobj,
        ignorevcs=cmdargs.ignorevcs,
        noprogress=cmdargs.noprogress,
        outputdir=cmdargs.outputdir
    )

#===============================================================================
@cli.Command(
    name='put',
    description='Archive using a straight copy.',
    args=get_archive_cli_args()
)
#===============================================================================
def _put(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = FMFactory.forPath(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='gz',
    description='Archive with gzip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _gzip(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "gzip", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='bz2',
    description='Archive with bzip2 compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _bzip2(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "bzip2", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='xz',
    description='Archive with xz compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _xz(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "xz", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='lz',
    description='Archive with lzip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _lz(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "lzip", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='zip',
    description='Archive with zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _zip(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveZip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='7z',
    description='Archive with p7zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _p7zip(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveP7Zip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='get',
    description='Restore from archive.',
    args=[
        cli.String('path', 'path(s) to restore', nargs='+'),
    ]
)
#===============================================================================
def _get(runner):
    read_configs(runner)
    for name in files:
        (path, fm) = choose_archive(name, **cmdargs_to_kwargs(runner.cmdargs))
        fm.restore(path)


#===============================================================================
@cli.Command(
    name='cmp',
    description='Compare with archive.',
    args=[
        cli.String('path', 'path(s) to compare', nargs='+'),
    ]
)
#===============================================================================
def _compare(runner):
    read_configs(runner)
    for name in files:
        (path, fm) = choose_archive(name, **cmdargs_to_kwargs(runner.cmdargs))
        fm.compare(path)


#===============================================================================
@cli.Command(
    name='generate-rc',
    description='Generate sample RC file to working directory.',
)
#===============================================================================
def _generate_rc(runner):
    CONFIG.generate()


#===============================================================================
def read_configs(runner, *directories):
#===============================================================================
    CONFIG.load_for_paths(runner.cmdargs.path, directories, '~', '.')


#===============================================================================
@cli.Main(
    description='Simple backup archiver.',
    support_verbose=True,
    support_dryrun=True,
    support_pause=True,
)
#===============================================================================
def _main(runner):
    console.set_verbose(runner.cmdargs.verbose)


#===============================================================================
if __name__ == '__main__':
#===============================================================================
    cli.main()
