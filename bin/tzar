#!/usr/bin/env python
# Copyright 2016 Steven Cooper
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#===============================================================================
#===============================================================================
# TZAR - simple archiving front end
#
# Features:
#
#   Multiple archive formats:
#
#     - gzip    standard with high speed and less compression
#     - bzip2   standard with better compression than gzip, but slower
#     - xz      newer standard with better compression than bzip2, but slower
#     - zip     multi-platform format with good speed/compression balance
#     - p7zip   slower high compression format
#     - lzip    another slower high compression format
#     - put     straight file copy
#
#   Performance:
#
#     Performance is determined by the external command line tool that is used
#     for a particular format, but it takes advantage of faster multi-threaded
#     archiving tools like pigz, pxz, lbzip2, and pbzip2 when available.
#
#   Operations:
#
#     - compress using format choice
#     - compare to archive (limited)
#     - restore from archive (limited)
#     - generate a configuration file template
#
#   Usability:
#
#     - Provides a simple command line interface, e.g. that allows creating an
#       archive without specifying an output file.
#     - Uses pv when it is available to display a real-time i/o progress meter.
#     - Supports per-location and global configuration files to fine-tune
#       default options for different directories, e.g. to always exclude local
#       temporary files from the archive.
#===============================================================================
#===============================================================================


import sys
import os
import re
from time import strftime
from glob import glob

from lib import import_scriptbase
from scriptbase import cli
from scriptbase import console
from scriptbase.configuration import ConfigSpec, Config
from scriptbase import disk
from scriptbase import shell


#=== Non-configurable globals ==================================================

PROGRAM_DIR, PROGRAM_NAME = os.path.split(os.path.realpath(sys.argv[0]))

# The platforms where "cp" doesn't support -a
#TODO: Add others (e.g. bsd?), even better - switch to shutil.
SIMPLE_CP_PLATFORMS = ['darwin']

# Display progress with "pv", if available.
PV_AVAILABLE = shell.find_executable('pv')

ARCHIVE_NAME_GLOB = '"%s"-[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]*'

TARBALL_TRAILER_RE = re.compile('^[.]%s/(.*)-([0-9]+-[0-9]+)([.]tar)?[.](gz|bz2)$'
                                    % PROGRAM_NAME)

NUMBER_WITH_DEFAULT_RE = re.compile('^[0-9]*$')

# Common command line options and arguments for archiving
def get_archive_cli_args():
    return [
        cli.Boolean('delete', 'delete files after archiving',
                   '-d', '--delete', default=False),
        cli.Boolean('ignoreobj', 'ignore %s' % ' '.join(CONFIG.data.BINARY_PATTERNS),
                   '--ignore-obj', default=False),
        cli.Boolean('ignorevcs', 'ignore %s subdirectories' % ' '.join(CONFIG.data.VCS_DIRECTORIES),
                   '--ignore-vcs', default=False),
        cli.Boolean('noprogress', 'disable progress meter',
                   '--no-progress', default=False),
        cli.String('outputdir', 'output directory',
                   '-o', '--output-dir'),
        cli.String('path', 'path(s) to archive', nargs='+'),
    ]


#=== Configuration dictionary with pseudo-attributes ===========================

CONFIG = Config('.%(PROGRAM_NAME)src' % globals(),
    ConfigSpec(
        'BINARY_PATTERNS',
        [
            '*.o',
            '*.so',
            '*.so.*',
            '*.co',
            '*.pyc',
            '*.pyd',
            '*.Plo',
            '*.la',
            '*.lai',
            '*.lo',
            '*.a',
            '*.dll',
            '*.DLL',
            '*.exe',
            '*.EXE',
            '*.lib',
            '*.LIB',
            '*.dylib',
            '*.jnilib',
            '*.jar',
            '*.deb',
            '*.rpm',
            '*.zip',
            '*.ZIP',
            '*.gz',
            '*.tgz',
            '*.bz2',
            '*.xz',
            '*.lz',
            '*.sym',
            '*.bin',
            '*/tags',
        ],
        'Binary file wildcard patterns that are optionally ignored.'
    ),
    ConfigSpec(
        'COPY_COMMAND',
        'cp -Rpv' if sys.platform in SIMPLE_CP_PLATFORMS else 'cp -av',
        'Command used for file copy operations.'
    ),
    ConfigSpec(
        'EXCLUDE_BINARIES',
        False,
        'Exclude binary files if True.'
    ),
    ConfigSpec(
        'EXCLUDE_OTHER_PATTERNS',
        [],
        'Wildcard patterns for other excluded files.'
    ),
    ConfigSpec(
        'EXCLUDE_VCS',
        False,
        'Exclude VCS directories if True.'
    ),
    ConfigSpec(
        'OUTPUT_DIRECTORY',
        '.%s' % PROGRAM_NAME,
        'Output subdirectory name.'
    ),
    ConfigSpec(
        'REPLACEMENT_GZIP',
        shell.find_executable('pigz'),
        'Compatible gzip replacement. By default pigz is used when available.'
    ),
    ConfigSpec(
        'REPLACEMENT_BZIP2',
        shell.find_executable('pbzip2', 'lbzip2'),
        'Compatible bzip2 replacement. By default pbzip2 or lbzip2 are used when available.'
    ),
    ConfigSpec(
        'REPLACEMENT_XZ',
        shell.find_executable('xz'),
        'Use xz as an external program to benefit from its multi-threading.'
    ),
    ConfigSpec(
        'REPLACEMENT_LZIP',
        shell.find_executable('plzip'),
        'Compatible lzip replacement. By default plzip is used when available.'
    ),
    ConfigSpec(
        'VCS_DIRECTORIES',
        [ '.svn', '.cvs', '.git' ],
        'VCS directory names that are optionally ignored.'
    ),
)


#===============================================================================

def quote_arg(*args):
    return '"%s"' % ''.join([s.replace('"', '\\"') for s in args])


#===============================================================================

class CommandBatch(object):
    class Failure(Exception):
        def __init__(self, rc):
            Exception.__init__(self, 'Command batch failed with return code %d' % rc)
    def __init__(self, echo=False, dryrun=False):
        self.echo   = echo
        self.dryrun = dryrun
        self.cmds   = []
        self.cur    = 0
    def add_command(self, *cmd):
        self.cmds.append(list(cmd))
        self.cur = len(self.cmds) - 1
        return self.cur
    def insert(self, *cmd):
        self.cmds.insert(self.cur, list(cmd))
        return self.cur
    def rewind(self, pos = 0):
        assert pos >= 0 and pos < len(self.cmds)
        self.cur = pos
    def add_args(self, *args):
        assert self.cur >= 0 and self.cur < len(self.cmds)
        self.cmds[self.cur].extend([arg for arg in args if arg is not None])
    def run(self):
        for cmd in self.cmds:
            scmd = ' '.join(cmd)
            if self.dryrun:
                console.info('>>> %s' % scmd)
            elif self.echo:
                console.info(scmd)
            if not self.dryrun:
                rc = os.system(scmd)
                if rc != 0:
                    raise CommandBatch.Failure(rc)


#===============================================================================

class ArchiveItem(object):

    class Batch(CommandBatch):

        def __init__(self, item):
            self.item = item
            CommandBatch.__init__(self, dryrun=item.dryrun)

        def add_exclude_args(self, option):
            def add_excludes(excludes, test=None, leader='', trailer=''):
                if test is None or test:
                    for exclude in excludes:
                        # Don't separate by whitespace when the option ends with '=' or '!', e.g. P7Zip.
                        if option[-1] in ('!', '='):
                            self.add_args(quote_arg(option, leader, exclude, trailer))
                        else:
                            self.add_args(option, quote_arg(leader, exclude, trailer))
            add_excludes(CONFIG.data.BINARY_PATTERNS, test=self.item.ignoreobj)
            add_excludes(CONFIG.data.VCS_DIRECTORIES, test=self.item.ignorevcs, leader='*/', trailer='/*')
            add_excludes(self.item.excludes)

        def add_metered_redirection_args(self, output_path):
            quoted_input  = quote_arg(self.item.path)
            quoted_output = quote_arg(output_path)
            if PV_AVAILABLE and not self.item.noprogress:
                self.add_args('-', quoted_input, '|', 'pv', '-rbt', '>', quoted_output)
                self.insert('echo', quote_arg('Creating "', quoted_output, '"...'))
            else:
                self.add_args(quoted_output, quoted_input)

        def add_move_command(self, src, dst):
            self.add_command('mv', '-v', quote_arg(src), quote_arg(dst))

        def add_copy_command(self, src, dst):
            self.add_command(CONFIG.data.COPY_COMMAND, quote_arg(src), quote_arg(dst))

        def add_move_or_copy_archive_command(self):
            if self.item.delete:
                self.add_move_command(self.item.path, self.item.archive)
            else:
                self.add_copy_command(self.item.path, self.item.archive)

        def add_compression_command(self, path):
            self.add_command(self.item.compression, quote_arg(path))

        def add_archive_compression_command(self):
            self.add_compression_command(self.item.archive)

        def add_cleanup(self):
            if self.item.delete:
                batch.add_command('rm', '-rvf', quote_arg(self.item.path))

    def __init__(self, path,
                 dryrun=False,
                 pause=False,
                 verbose=False,
                 delete=False,
                 excludes=[],
                 ignoreobj=False,
                 ignorevcs=False,
                 noprogress=False,
                 outputdir=None):
        self.path        = os.path.normpath(path)
        self.dryrun      = dryrun
        self.pause       = pause
        self.verbose     = verbose
        self.delete      = delete
        self.excludes    = excludes
        self.ignoreobj   = ignoreobj
        self.ignorevcs   = ignorevcs
        self.outputdir   = outputdir if outputdir else CONFIG.data.OUTPUT_DIRECTORY
        self.timestamp   = get_timestamp()
        self.name        = '%s-%s' % (self.path.replace('/', '_'), self.timestamp)
        self.archive     = os.path.join(self.outputdir, self.name)
        self.compression = None
        self.noprogress  = noprogress
        self.check_output_directory()
        if CONFIG.data.EXCLUDE_BINARIES:
            self.ignoreobj = True
        if CONFIG.data.EXCLUDE_VCS:
            self.ignorevcs = True
        self.excludes.extend(CONFIG.data.EXCLUDE_OTHER_PATTERNS)

    def check_output_directory(self):
        if not os.path.isdir(self.outputdir):
            if os.path.exists(self.outputdir):
                console.abort('"%s" exists and is not a directory' % self.outputdir)
            console.info('Creating %s...' % self.outputdir)
            try:
                os.mkdir(self.outputdir)
            except (IOError, OSError) as e:
                console.abort('Unable to create output directory', self.outputdir, e)

    def compare(self):
        return self._perform('compare')

    def create(self):
        return self._perform('create')

    def restore(self):
        return self._perform('restore')

    def _perform(self, name):
        perform_method = getattr(self, 'build_%s_batch' % name)
        if not perform_method:
            console.abort('%s has no "%s" method.' % (self.__class__.__name__, name))
        batch = ArchiveItem.Batch(self)
        perform_method(batch)
        return batch.run()


#===============================================================================

class ArchiveTarball(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.tar':
            return None
        if m.group(4) == 'bz2':
            return ArchiveTarball(path, 'bzip2', **kwargs)
        if m.group(4) == 'xz':
            return ArchiveTarball(path, 'xz', **kwargs)
        if m.group(4) == 'lz':
            return ArchiveTarball(path, 'lzip', **kwargs)
        return ArchiveTarball(path, 'gzip', **kwargs)

    def __init__(self, path, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression
        if self.compression == 'bzip2':
            self.external_compression_program = CONFIG.data.REPLACEMENT_BZIP2
            self.tar_compression_options = 'j'
            self.tar_extension = '.tar.bz2'
        elif self.compression == 'xz':
            # xz has a threading
            if  'XZ_OPT' in os.environ:
                os.environ['XZ_OPT'] = '%s --threads=0' % os.environ['XZ_OPT']
            else:
                os.environ['XZ_OPT'] = '--threads=0'
            self.tar_compression_options = 'J'
            self.external_compression_program = CONFIG.data.REPLACEMENT_XZ
            self.tar_extension = '.tar.xz'
        elif self.compression == 'lzip':
            # does this work for lzip, like xz?
            if  'LZ_OPT' in os.environ:
                os.environ['LZ_OPT'] = '%s --threads=0' % os.environ['LZ_OPT']
            else:
                os.environ['LZ_OPT'] = '--threads=0'
            self.tar_compression_options = None
            self.external_compression_program = CONFIG.data.REPLACEMENT_LZIP
            self.tar_extension = '.tar.lz'
        else:
            self.tar_compression_options = 'z'
            self.external_compression_program = CONFIG.data.REPLACEMENT_GZIP
            self.tar_extension = '.tar.gz'
        verbose_option = 'v' if not PV_AVAILABLE or self.noprogress else ''
        self.tar_create_options = []
        if self.external_compression_program:
            compression_options = ''
            self.tar_create_options.extend(['--use-compress-program',
                                            self.external_compression_program])
        else:
            compression_options = self.tar_compression_options
        self.tar_create_options.append('-c%s%s' % (verbose_option, compression_options))
        self.tar_create_options.append('-f')
        self.tar_restore_options = '-%s%s%s' % ('x', self.tar_compression_options, 'pf')
        self.tar_compare_options = '-%s%s%s' % ('d', self.tar_compression_options, 'f')

    def build_create_batch(self, batch):
        batch.add_command('tar')
        batch.add_exclude_args('--exclude')
        batch.add_args(*self.tar_create_options)
        batch.add_metered_redirection_args(''.join([self.archive, self.tar_extension]))
        batch.add_cleanup()

    def build_restore_batch(self, batch):
        restore_to_dir = disk.get_versioned_path(os.path.basename(self.path)[:-len(self.tar_extension)])
        os.mkdir(restore_to_dir)
        console.info('Restoring to "%s"...' % restore_to_dir)
        #TODO: Untested
        batch.add_command('tar', self.tar_restore_options, quote_arg(self.path),
                          '--strip-components', '1', '-C', quote_arg(restore_to_dir))

    def build_compare_batch(self, batch):
        #TODO: Untested - runs against working directory?
        batch.add_command('tar', self.tar_compare_options, quote_arg(self.path))


#===============================================================================

class ArchiveZip(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.zip':
            return None
        return ArchiveZip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def build_create_batch(self, batch):
        batch.add_command('zip', '-r', '--symlinks')
        batch.add_args(quote_arg(self.archive, '.zip'), quote_arg(self.path))
        batch.add_exclude_args('--exclude')
        batch.add_cleanup()

    def build_restore_batch(self, batch):
        console.abort('Restore is not yet implemented for zip compression.')

    def build_compare_batch(self, batch):
        console.abort('Compare is not yet implemented for zip compression.')


#===============================================================================

class ArchiveP7Zip(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is None or m.group(3) != '.7z':
            return None
        return ArchiveP7Zip(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def build_create_batch(self, batch):
        batch.add_command('7za', 'a')
        batch.add_exclude_args('-xr!')
        batch.add_args(quote_arg(self.archive, '.7z'), quote_arg(self.path))
        batch.add_cleanup()

    def build_restore_batch(self, batch):
        console.abort('Restore is not yet implemented for p7zip compression.')

    def build_compare_batch(self, batch):
        console.abort('Compare is not yet implemented for p7zip compression.')


#===============================================================================

class ArchiveCompressedFile(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        ext = os.path.splitext(path)[1]
        if m is not None:
            return None
        if ext == '.gz':
            return ArchiveCompressedFile(path, 'gzip', **kwargs)
        if ext == '.bz2':
            return ArchiveCompressedFile(path, 'bzip2', **kwargs)
        if ext == '.xz':
            return ArchiveCompressedFile(path, 'xz', **kwargs)
        if ext == '.lz':
            return ArchiveCompressedFile(path, 'lzip', **kwargs)
        return None

    def __init__(self, compression, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)
        self.compression = compression

    def build_create_batch(self, batch):
        batch.add_move_or_copy_archive_command()
        batch.add_archive_compression_command()

    def build_restore_batch(self, batch):
        console.abort('Restore is not yet implemented for compressed files.')

    def build_compare_batch(self, batch):
        console.abort('Compare is not yet implemented for compressed files.')


#===============================================================================

class ArchiveDirectory(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        if not os.path.isdir(path):
            return None
        return ArchiveDirectory(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def build_create_batch(self, batch):
        batch.add_move_or_copy_archive_command()

    def build_restore_batch(self, batch):
        target = disk.get_versioned_path(self.path)
        batch.add_copy_command(self.path, target)
        console.info('Restoring to "%s"...' % target)

    def build_compare_batch(self, batch):
        console.abort('Compare is not yet implemented for archived directories.')


#===============================================================================

class ArchiveFile(ArchiveItem):

    @staticmethod
    def archive_for_path(path, **kwargs):
        m = TARBALL_TRAILER_RE.match(path)
        if m is not None or os.path.isdir(path):
            return None
        return ArchiveFile(path, **kwargs)

    def __init__(self, path, **kwargs):
        ArchiveItem.__init__(self, path, **kwargs)

    def build_create_batch(self, batch):
        batch.add_move_or_copy_archive_command()

    def build_restore_batch(self, batch):
        target = disk.get_versioned_path(self.path)
        batch.add_copy_command(self.path, target)
        console.info('Restoring to "%s"...' % target)

    def build_compare_batch(self, batch):
        console.abort('Compare is not yet implemented for archived files.')


#===============================================================================

class FMFactory(object):
    @staticmethod
    def archive_for_path(path, **kwargs):
        for fmCls in (
                ArchiveTarball,
                ArchiveZip,
                ArchiveP7Zip,
                ArchiveDirectory,
                ArchiveFile,
                ArchiveCompressedFile
        ):
            archive = fmCls.archive_for_path(path, **kwargs)
            if archive:
                return archive
        console.abort('"%s" is not a supported type' % path)


#===============================================================================

def choose_archive(name, **kwargs):

    if not os.path.isdir(CONFIG.data.OUTPUT_DIRECTORY):
        console.abort('No %s directory exists' % CONFIG.data.OUTPUT_DIRECTORY)
    if name[-1] == '/':
        name = name[:-1]
    pat = os.path.join(CONFIG.data.OUTPUT_DIRECTORY, ARCHIVE_NAME_GLOB % name)
    archives = []
    for a in os.popen('ls %s' % pat):
        archives.insert(0, a.strip())
    if len(archives) == 0:
        console.abort('No archives found')
    console.info('Newest archive is at the top.  Empty input or zero response cancels the action.')
    for i in range(len(archives)):
        console.info('%d) %s' % (i+1, archives[i]))
    console.info('')
    path = None
    while path is None:
        i = int(console.prompt_re('Select archive (1-n [none])', NUMBER_WITH_DEFAULT_RE, '0'))
        if i <= 0:
            console.abort('Canceled')
        if i-1 < len(archives):
            path = archives[i-1]
        else:
            console.error('bad index %d' % i)
    return FMFactory.archive_for_path(path, **kwargs)


#===============================================================================

def get_timestamp():
    return strftime('%y%m%d-%H%M%S')


#===============================================================================

def cmdargs_to_kwargs(cmdargs):
    return dict(
        dryrun=cmdargs.dryrun,
        pause=cmdargs.pause,
        verbose=cmdargs.verbose,
        delete=cmdargs.delete,
        ignoreobj=cmdargs.ignoreobj,
        ignorevcs=cmdargs.ignorevcs,
        noprogress=cmdargs.noprogress,
        outputdir=cmdargs.outputdir
    )

#===============================================================================
@cli.Command(
    name='put',
    description='Archive using a straight copy.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            archive = FMFactory.archive_for_path(path, **cmdargs_to_kwargs(runner.cmdargs))
            archive.create()


#===============================================================================
@cli.Command(
    name='gz',
    description='Archive with gzip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "gzip", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='bz2',
    description='Archive with bzip2 compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "bzip2", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='xz',
    description='Archive with xz compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "xz", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='lz',
    description='Archive with lzip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveTarball(path, "lzip", **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='zip',
    description='Archive with zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveZip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='7z',
    description='Archive with p7zip compression.',
    args=get_archive_cli_args()
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for path_pat in runner.cmdargs.path:
        for path in glob(path_pat):
            fm = ArchiveP7Zip(path, **cmdargs_to_kwargs(runner.cmdargs))
            fm.create()


#===============================================================================
@cli.Command(
    name='get',
    description='Restore from archive.',
    args=[
        cli.String('path', 'path(s) to restore', nargs='+'),
    ]
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for name in files:
        archive = choose_archive(name, **cmdargs_to_kwargs(runner.cmdargs))
        archive.restore()


#===============================================================================
@cli.Command(
    name='cmp',
    description='Compare with archive.',
    args=[
        cli.String('path', 'path(s) to compare', nargs='+'),
    ]
)
#===============================================================================
def _(runner):
    read_configs(runner)
    for name in files:
        archive = choose_archive(name, **cmdargs_to_kwargs(runner.cmdargs))
        archive.compare()


#===============================================================================
@cli.Command(
    name='generate-rc',
    description='Generate sample RC file to working directory.',
)
#===============================================================================
def _(runner):
    CONFIG.generate()


#===============================================================================
def read_configs(runner, *directories):
#===============================================================================
    CONFIG.load_for_paths(runner.cmdargs.path, directories, '~', '.')


#===============================================================================
@cli.Main(
    description='Simple backup archiver.',
    support_verbose=True,
    support_dryrun=True,
    support_pause=True,
)
#===============================================================================
def _(runner):
    console.set_verbose(runner.cmdargs.verbose)


#===============================================================================
if __name__ == '__main__':
#===============================================================================
    try:
        cli.main()
    except CommandBatch.Failure as e:
        console.abort(e)
    except KeyboardInterrupt:
        console.abort('Interrupted by user.')
