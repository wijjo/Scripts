#!/usr/bin/env python3

"""External drive backup."""

import sys
import os
import argparse
import subprocess
import time
import plistlib
import atexit


class Constants:
    """Constant data."""
    output_name_format = '{name}-{timestamp}.img.gz'
    app_description = 'Mac volume image reader/writer'


class CLI:
    """
    CLI toolkit class.

    Friendlier wrapper for argparse functionality, plus additional utility
    functions that are frequently useful for CLI programs.
    """

    commands = []
    verbose = False
    platform = None
    files_to_delete = []

    class Command:
        """Data for CLI command."""
        def __init__(self, func, name, add_parser_kwargs, arguments):
            self.func = func
            self.name = name
            self.add_parser_kwargs = add_parser_kwargs
            self.arguments = arguments

    class Argument:
        """CLI command argparse.add_argument() arguments."""
        def __init__(self, *add_argument_args, **add_argument_kwargs):
            self.add_argument_args = add_argument_args
            self.add_argument_kwargs = add_argument_kwargs

    @classmethod
    def command(cls, name, **add_parser_kwargs):
        """
        Decorator for functions implementing CLI sub-commands.

        Accepts any ArgumentParser constructor argument plus an "arguments" keyword
        that may be assigned a list of Argument objects.
        """
        arguments = add_parser_kwargs.pop('arguments')
        def wrapper(func):
            cls.commands.append(cls.Command(func, name, add_parser_kwargs, arguments))
            return func
        return wrapper

    @classmethod
    def main(cls, description, supported_platforms=None):
        """Application main, including CLI command line parsing."""
        parser = argparse.ArgumentParser(description=description)
        parser.add_argument('-v', '--verbose', dest='VERBOSE', action='store_true',
                            help='enable verbose output')
        command_parsers = parser.add_subparsers(dest='COMMAND', metavar='COMMAND', required=True)
        commands_by_name = {}
        for command in cls.commands:
            commands_by_name[command.name] = command
            command_parser = command_parsers.add_parser(command.name, **command.add_parser_kwargs)
            for argument in command.arguments:
                command_parser.add_argument(*argument.add_argument_args,
                                            **argument.add_argument_kwargs)
        args = parser.parse_args()
        cls.verbose = args.VERBOSE
        if supported_platforms:
            for platform in supported_platforms:
                if platform.platform == sys.platform:
                    cls.platform = platform
                    break
            else:
                cls.abort('The "{}" platform is not supported.'.format(sys.platform))
        atexit.register(cls.at_exit)
        commands_by_name[args.COMMAND].func(args)

    @classmethod
    def at_exit(cls):
        """Delete partial files, etc.."""
        for file_to_delete in cls.files_to_delete:
            if os.path.exists(file_to_delete):
                try:
                    print('Removing partial file: {}'.format(file_to_delete))
                    os.remove(file_to_delete)
                except (IOError, OSError) as exc:
                    print(str(exc))

    @classmethod
    def register_file_to_delete(cls, path):
        """Add a file to be deleted at exit."""
        if path not in cls.files_to_delete:
            cls.files_to_delete.append(path)

    @classmethod
    def unregister_file_to_delete(cls, path):
        """Remove a file from the to-be-deleted at exit list."""
        if path in cls.files_to_delete:
            cls.files_to_delete.remove(path)

    @classmethod
    def abort(cls, message):
        """Display critical error and exit."""
        sys.stderr.write('CRITICAL: {}{}'.format(message, os.linesep))
        sys.exit(1)

    @classmethod
    def info(cls, message):
        """Display general info message."""
        sys.stdout.write('{}{}'.format(message, os.linesep))

    @classmethod
    def warning(cls, message):
        """Display warning message."""
        sys.stderr.write('WARNING: {}{}'.format(message, os.linesep))

    @classmethod
    def error(cls, message):
        """Display error message."""
        sys.stderr.write('ERROR: {}{}'.format(message, os.linesep))


class Volume:
    """Data for a disk volume."""
    def __init__(self, disk_dev, volume_dev, filesystem, size, name, uuid, mountpoint):
        self.disk_dev = disk_dev
        self.raw_disk_dev = '/dev/r{}'.format(self.disk_dev)
        self.volume_dev = volume_dev
        self.filesystem = filesystem
        self.size = int(size)
        self.name = name
        self.uuid = uuid
        self.mountpoint = mountpoint


class MacOSPlatform:
    """Platform-specific functionality for MacOS."""

    platform = "darwin"

    @classmethod
    def list_volumes(cls):
        """Provide data for currently visible volumes."""
        volumes = []
        proc = subprocess.run(['diskutil', 'list', '-plist'],
                              capture_output=True, check=True)
        for disk_or_partition in plistlib.loads(
                proc.stdout)['AllDisksAndPartitions']:
            for volume in disk_or_partition.get('Partitions', []):
                volumes.append(Volume(
                    disk_or_partition['DeviceIdentifier'],
                    volume.get('DeviceIdentifier'),
                    volume.get('Content'),
                    volume.get('Size'),
                    volume.get('VolumeName'),
                    volume.get('VolumeUUID'),
                    volume.get('MountPoint'),
                ))
        return volumes

    @classmethod
    def unmount(cls, volume):
        """Unmount a volume based on a mountpoint."""
        subprocess.run(['diskutil', 'unmount', volume.mountpoint],
                       check=True)


def volumes_for_identifier(identifier):
    """Find volume by volume name, mountpoint, UUID, or device name."""
    return [
        volume
        for volume in CLI.platform.list_volumes()
        if identifier in [
            volume.name,
            volume.mountpoint,
            volume.uuid,
            volume.disk_dev,
        ]
    ]


def find_in_path(path, name, executable=False):
    """
    Find a file in a shell-compatible path string.

    Return path to name if found in path, or None if not found.  Require
    executable if executable is True.
    """
    for directory in path.split(os.pathsep):
        chk_path = os.path.join(directory, name)
        if executable:
            if sys.platform in ('cygwin', 'windows'):
                for ext in ('', '.exe', '.bat', '.cmd', '.com'):
                    if os.path.exists(chk_path + ext):
                        return chk_path
            elif os.path.exists(chk_path) and (os.stat(chk_path)[0] & 0o111) != 0:
                return chk_path
        elif os.path.exists(chk_path):
            return chk_path
    return None


def find_executable(*names):
    """
    Find an executable program in the shell PATH.

    If multiple names are specified return the first one found in the path.

    Return path to first name found in PATH.
    """
    env_path = os.environ['PATH']
    for name in names:
        path = find_in_path(env_path, name, executable=True)
        if path:
            return os.path.realpath(path)
    return None


def volume_for_identifier(identifier):
    """Find exactly one volume by identifier (see volumes_for_identifier())."""
    volumes = volumes_for_identifier(identifier)
    if not volumes:
        CLI.abort('No volume for "{}" was found.'.format(identifier))
    if len(volumes) != 1:
        CLI.abort('There are {} volumes for "{}".'.format(len(volumes), identifier))
    return volumes[0]


def volume_unmount(volume):
    """Unmount a volume based on a mountpoint."""
    CLI.platform.unmount(volume)


def get_volume_output_path(volume_name, output_dir):
    """Generate an output path for a volume backup file."""
    return os.path.join(output_dir, Constants.output_name_format.format(
        name=volume_name,
        timestamp=time.strftime('%Y-%m-%d-%H%M%S')))


def gzip_stream(input_path, output_path):
    """Write input stream to gzip'ed output file."""
    gzip_cmd = find_executable('pigz') or find_executable('gzip')
    if not gzip_cmd:
        CLI.abort('No gzip command found.')
    # Otherwise use pigz for faster multi-core compression.
    CLI.info('Compressing with "pigz". Use CTRL-T for status.')
    cmd = 'sudo dd if={input} bs=1M | {gzip} -c -f - > {output}'.format(
        input=input_path,
        gzip=gzip_cmd,
        output=output_path)
    CLI.info(cmd)
    retcode = os.system(cmd)
    if retcode != 0:
        CLI.abort('Output command failed with return code {}.'.format(retcode))


@CLI.command(
    'save',
    help='make a volume image',
    arguments=[
        CLI.Argument(dest='INPUT_VOLUME', nargs=1,
                     help='volume name, device, UUID, or mountpoint'),
        CLI.Argument(dest='OUTPUT_DIR', nargs=1,
                     help='output directory for backup image'),
    ]
)
def cli_save(args):
    """Back up input device."""
    volume = volume_for_identifier(args.INPUT_VOLUME[0])
    if volume.mountpoint:
        CLI.info('Unmounting: {}'.format(volume.mountpoint))
        volume_unmount(volume)
    output_path = get_volume_output_path(volume.name, args.OUTPUT_DIR[0])
    CLI.info('Input device: {}'.format(volume.raw_disk_dev))
    CLI.info(' Output path: {}'.format(output_path))
    CLI.info('-----')
    CLI.register_file_to_delete(output_path)
    gzip_stream(volume.raw_disk_dev, output_path)
    CLI.unregister_file_to_delete(output_path)


if __name__ == '__main__':
    try:
        CLI.main(Constants.app_description, supported_platforms=[MacOSPlatform])
    except KeyboardInterrupt:
        CLI.info('')
        CLI.info('<break>')
        sys.exit(2)
    except subprocess.CalledProcessError as exc:
        CLI.abort(str(exc))
    except (IOError, OSError) as exc:
        CLI.abort(str(exc))
