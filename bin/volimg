#!/usr/bin/env python3

"""External drive backup."""

import sys
import os
import subprocess
import time
import atexit

try:
    from scriptbase.argdeco import CLI
except ImportError:
    sys.path.insert(0, os.path.join(
        os.path.dirname(os.path.dirname(__file__)), 'ext', 'scriptbase'))
    from scriptbase.argdeco import CLI
from scriptbase import console  #pylint: disable=import-error
from scriptbase import disk     #pylint: disable=import-error


class Constants:
    """Constant data."""
    output_name_format = '{name}-{timestamp}.img.{ext}'
    app_description = 'Mac volume image reader/writer'


class Cleanup:
    """Data used for cleanup."""
    files_to_delete = []


def generate_volume_output_path(volume_name, output_dir, compression):
    """Generate an output path for a volume backup file."""
    ext = 'gz' if compression == 'gzip' else compression
    return os.path.join(output_dir, Constants.output_name_format.format(
        name=volume_name,
        timestamp=time.strftime('%Y-%m-%d-%H%M%S'),
        ext=ext))


def get_umounted_volume(identifier):
    """Provide unmounted volume data based on name, device, UUID, or mountpoint."""
    volume = disk.volume_for_identifier(identifier)
    if volume and volume.mountpoint:
        console.info('Unmounting: {}'.format(volume.mountpoint))
        disk.volume_unmount(volume)
    return volume


def at_exit():
    """Delete partial files, etc.."""
    for file_to_delete in Cleanup.files_to_delete:
        if os.path.exists(file_to_delete):
            try:
                console.info('Removing partial file: {}'.format(file_to_delete))
                os.remove(file_to_delete)
            except (IOError, OSError) as exc:
                console.error(exc)


@CLI.Main(
    description=Constants.app_description,
    groups=[
        CLI.CommandGroup('commands'),
    ]
)
def main(_args):
    """Called by cli module at startup."""
    atexit.register(at_exit)


@CLI.Command(
    'backup',
    description='make a volume image backup',
    arguments=[
        CLI.Opt.String('COMPRESSION',
                       ['-c', '--compression'],
                       'compression, "gzip" (default) or "xz"',
                       choices=['gzip', 'xz']),
        CLI.Arg.String('INPUT_VOLUME',
                       'volume name, device, UUID, or mountpoint'),
        CLI.Arg.String('OUTPUT_DIR',
                       'output directory for backup image'),
    ]
)
def cli_backup(args):
    """Back up from an input device to a gzip-compressed image file."""
    ctx = console.Context()
    volume = get_umounted_volume(args.INPUT_VOLUME)
    ctx.volume_name = volume.name
    ctx.raw_disk = volume.raw_disk_dev
    ctx.volume_summary = volume.short_summary()
    ctx.compression = args.COMPRESSION or 'gzip'
    ctx.output_path = generate_volume_output_path(
        volume.name, args.OUTPUT_DIR, ctx.compression)
    ctx.info('Input device: {raw_disk} ({volume_summary})')
    ctx.info(' Output path: {output_path}')
    ctx.info(' Compression: {compression}')
    ctx.pause('Ready to backup volume?')
    Cleanup.files_to_delete.append(ctx.output_path)
    disk.backup_device(ctx.raw_disk, ctx.output_path, compression=ctx.compression)
    Cleanup.files_to_delete.pop()


@CLI.Command(
    'restore',
    description='restore a volume image backup',
    arguments=[
        CLI.Arg.String('IMAGE_PATH',
                       'backup image path'),
        CLI.Arg.String('OUTPUT_VOLUME',
                       'volume name, device, UUID, or mountpoint'),
    ]
)
def cli_restore(args):
    """Restore from a gzip-compressed image file to an output device."""
    ctx = console.Context()
    ctx.input_path = args.IMAGE_PATH
    if not os.path.isfile(ctx.input_path):
        ctx.abort('Image path "{input_path}" does not exist.')
    if ctx.input_path.endswith('.img.gz'):
        ctx.compression = 'gzip'
    elif ctx.input_path.endswith('.img.xz'):
        ctx.compression = 'xz'
    else:
        ctx.abort('Image path "{input_path}" does not have a ".img.<compression>" extension.')
    volume = get_umounted_volume(args.OUTPUT_VOLUME)
    ctx.raw_disk = volume.raw_disk_dev
    ctx.summary = volume.short_summary()
    ctx.info('   Input path: {input_path}')
    ctx.info('Output device: {raw_disk} ({summary})')
    ctx.info('  Compression: {compression}')
    ctx.pause('Ready to restore volume?')
    disk.restore_device(ctx.raw_disk, ctx.input_path, compression=ctx.compression)


if __name__ == '__main__':
    try:
        CLI.main()
    except KeyboardInterrupt:
        console.info('')
        console.info('<break>')
        sys.exit(2)
    except subprocess.CalledProcessError as exc:
        console.abort(exc)
    except (IOError, OSError) as exc:
        console.abort(exc)
