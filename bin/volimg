#!/usr/bin/env python3

"""External drive backup."""

import sys
import os
import subprocess
import time
import atexit

try:
    from scriptbase import cli
except ImportError:
    sys.path.insert(0, os.path.join(
        os.path.dirname(os.path.dirname(__file__)), 'ext', 'scriptbase'))
    from scriptbase import cli
from scriptbase import console  #pylint: disable=import-error
from scriptbase import disk     #pylint: disable=import-error


class Constants:
    """Constant data."""
    output_name_format = '{name}-{timestamp}.img.{ext}'
    app_description = 'Mac volume image reader/writer'


class Cleanup:
    """Data used for cleanup."""
    files_to_delete = []


def generate_volume_output_path(volume_name, output_dir, compression):
    """Generate an output path for a volume backup file."""
    ext = 'gz' if compression == 'gzip' else compression
    return os.path.join(output_dir, Constants.output_name_format.format(
        name=volume_name,
        timestamp=time.strftime('%Y-%m-%d-%H%M%S'),
        ext=ext))


def get_umounted_volume(identifier):
    """Provide unmounted volume data based on name, device, UUID, or mountpoint."""
    volume = disk.volume_for_identifier(identifier)
    if volume and volume.mountpoint:
        console.info('Unmounting: {}'.format(volume.mountpoint))
        disk.volume_unmount(volume)
    return volume


def at_exit():
    """Delete partial files, etc.."""
    for file_to_delete in Cleanup.files_to_delete:
        if os.path.exists(file_to_delete):
            try:
                console.info('Removing partial file: {}'.format(file_to_delete))
                os.remove(file_to_delete)
            except (IOError, OSError) as exc:
                console.error(exc)


@cli.Main(Constants.app_description)
def main(_runner):
    """Called by cli module at startup."""
    atexit.register(at_exit)


@cli.Command(
    name='backup',
    description='make a volume image backup',
    args=[
        cli.String('INPUT_VOLUME', 'volume name, device, UUID, or mountpoint', nargs=1),
        cli.String('OUTPUT_DIR', 'output directory for backup image', nargs=1),
        cli.String('COMPRESSION', 'compression, "gzip" (default) or "xz"',
                   '-c', '--compression'),
    ]
)
def cli_backup(runner):
    """Back up from an input device to a gzip-compressed image file."""
    with runner.context() as ctx:
        volume = get_umounted_volume(runner.arg.INPUT_VOLUME[0])
        ctx.volume_name = volume.name
        ctx.raw_disk = volume.raw_disk_dev
        ctx.volume_summary = volume.short_summary()
        ctx.compression = runner.arg.COMPRESSION or 'gzip'
        ctx.output_path = generate_volume_output_path(
            volume.name, runner.arg.OUTPUT_DIR[0], ctx.compression)
        ctx.info('Input device: {raw_disk} ({volume_summary})')
        ctx.info(' Output path: {output_path}')
        ctx.info(' Compression: {compression}')
        ctx.pause('Ready to backup volume?')
        Cleanup.files_to_delete.append(ctx.output_path)
        disk.backup_device(ctx.raw_disk, ctx.output_path, compression=ctx.compression)
        Cleanup.files_to_delete.pop()


@cli.Command(
    name='restore',
    description='restore a volume image backup',
    args=[
        cli.String('IMAGE_PATH', 'backup image path', nargs=1),
        cli.String('OUTPUT_VOLUME', 'volume name, device, UUID, or mountpoint', nargs=1),
    ]
)
def cli_restore(runner):
    """Restore from a gzip-compressed image file to an output device."""
    with runner.context() as ctx:
        ctx.input_path = runner.arg.IMAGE_PATH[0]
        if not os.path.isfile(ctx.input_path):
            ctx.abort('Image path "{input_path}" does not exist.')
        if ctx.input_path.endswith('.img.gz'):
            ctx.compression = 'gzip'
        elif ctx.input_path.endswith('.img.xz'):
            ctx.compression = 'xz'
        else:
            ctx.abort('Image path "{input_path}" does not have a ".img.<compression>" extension.')
        volume = get_umounted_volume(runner.arg.OUTPUT_VOLUME[0])
        ctx.raw_disk = volume.raw_disk_dev
        ctx.summary = volume.short_summary()
        ctx.info('   Input path: {input_path}')
        ctx.info('Output device: {raw_disk} ({summary})')
        ctx.info('  Compression: {compression}')
        ctx.pause('Ready to restore volume?')
        disk.restore_device(ctx.raw_disk, ctx.input_path, compression=ctx.compression)


if __name__ == '__main__':
    try:
        cli.main()
    except KeyboardInterrupt:
        console.info('')
        console.info('<break>')
        sys.exit(2)
    except subprocess.CalledProcessError as exc:
        console.abort(str(exc))
    except (IOError, OSError) as exc:
        console.abort(str(exc))
