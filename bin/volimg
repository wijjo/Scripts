#!/usr/bin/env python3

"""External drive backup."""

import sys
import os
import subprocess
import time
import atexit

try:
    from scriptbase import cli
except ImportError:
    sys.path.insert(0, os.path.join(
        os.path.dirname(os.path.dirname(__file__)), 'ext', 'scriptbase'))
    from scriptbase import cli
from scriptbase import console  #pylint: disable=import-error
from scriptbase import disk     #pylint: disable=import-error


class Constants:
    """Constant data."""
    output_name_format = '{name}-{timestamp}.img.gz'
    app_description = 'Mac volume image reader/writer'


class Cleanup:
    """Data used for cleanup."""
    files_to_delete = []


def generate_volume_output_path(volume_name, output_dir):
    """Generate an output path for a volume backup file."""
    return os.path.join(output_dir, Constants.output_name_format.format(
        name=volume_name,
        timestamp=time.strftime('%Y-%m-%d-%H%M%S')))


def get_umounted_volume(identifier):
    """Provide unmounted volume data based on name, device, UUID, or mountpoint."""
    volume = disk.volume_for_identifier(identifier)
    if volume and volume.mountpoint:
        console.info('Unmounting: {}'.format(volume.mountpoint))
        disk.volume_unmount(volume)
    return volume


def at_exit():
    """Delete partial files, etc.."""
    for file_to_delete in Cleanup.files_to_delete:
        if os.path.exists(file_to_delete):
            try:
                console.info('Removing partial file: {}'.format(file_to_delete))
                os.remove(file_to_delete)
            except (IOError, OSError) as exc:
                console.error(exc)


@cli.Main(Constants.app_description)
def main(_runner):
    """Called by cli module at startup."""
    atexit.register(at_exit)


@cli.Command(
    name='backup',
    description='make a volume image backup',
    args=[
        cli.String('INPUT_VOLUME', 'volume name, device, UUID, or mountpoint', nargs=1),
        cli.String('OUTPUT_DIR', 'output directory for backup image', nargs=1),
    ]
)
def cli_backup(runner):
    """Back up from an input device to a gzip-compressed image file."""
    volume = get_umounted_volume(runner.arg.INPUT_VOLUME[0])
    output_path = generate_volume_output_path(volume.name, runner.arg.OUTPUT_DIR[0])
    console.info('Input device: {} ({})'.format(volume.raw_disk_dev, volume.short_summary()))
    console.info(' Output path: {}'.format(output_path))
    console.pause('Ready to backup volume?')
    Cleanup.files_to_delete.append(output_path)
    disk.create_device_image(volume.raw_disk_dev, output_path, compression='gzip')
    Cleanup.files_to_delete.pop()


@cli.Command(
    name='restore',
    description='restore a volume image backup',
    args=[
        cli.String('IMAGE_PATH', 'backup image path', nargs=1),
        cli.String('OUTPUT_VOLUME', 'volume name, device, UUID, or mountpoint', nargs=1),
    ]
)
def cli_restore(runner):
    """Restore from a gzip-compressed image file to an output device."""
    input_path = runner.arg.IMAGE_PATH[0]
    if not os.path.isfile(input_path):
        console.abort('Image path "{}" does not exist.'.format(input_path))
    if not input_path.endswith('.img.gz'):
        console.abort('Image path "{}" does not have a ".img.gz" extension.'.format(input_path))
    volume = get_umounted_volume(runner.arg.OUTPUT_VOLUME[0])
    console.info('   Input path: {}'.format(input_path))
    console.info('Output device: {} ({})'.format(volume.raw_disk_dev, volume.short_summary()))
    console.pause('Ready to restore volume?')
    disk.restore_device_image(volume.raw_disk_dev, input_path, compression='gzip')


if __name__ == '__main__':
    try:
        cli.main()
    except KeyboardInterrupt:
        console.info('')
        console.info('<break>')
        sys.exit(2)
    except subprocess.CalledProcessError as exc:
        console.abort(str(exc))
    except (IOError, OSError) as exc:
        console.abort(str(exc))
