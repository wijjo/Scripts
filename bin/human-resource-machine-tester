#!/usr/bin/env python3

import sys
import os
from argparse import ArgumentParser
import yaml
import copy
import inspect
import collections


# Make YAML use ordered dictionaries so that code blocks are ordered.
# http://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
def dict_constructor(loader, node):
    return collections.OrderedDict(loader.construct_pairs(node))
yaml.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, dict_constructor)


class CompileError(Exception):
    pass


class RunError(Exception):
    pass


class MachineExit(Exception):
    pass


class CodeLocation:
    def __init__(self, block=None, line_index=None):
        self.block = block
        self.line_index = line_index


class Instruction:
    def __init__(self, op, func, args):
        self.op = op
        self.func = func
        self.args = args
    def execute(self):
        return self.func(*self.args)
    def __str__(self):
        return ' '.join([self.op] + ['{}'.format(arg) for arg in self.args])


def _value_string(value):
    if type(value) is list or type(value) is tuple:
        return '({})'.format(' '.join([_value_string(v) for v in value]))
    return '-' if value is None else '{}'.format(value)

class Machine:

    def __init__(self, inbox, blocks, trace=False):
        self.inbox = copy.copy(inbox)
        self.blocks = blocks
        self.trace = trace
        self.num_steps = 0
        self.registers = [None] * 10
        self.current = None
        self.outbox = []
        self.instructions = []
        self.compile_location = CodeLocation()
        self.run_index = 0

    def step(self):
        '''
        Execute current instruction.
        Return a Summary object when execution completes or None to continue.
        '''
        if not self.instructions:
            raise RunError('No compiled instructions are available.')
        try:
            if self.trace:
                print('c{}  r{}  i{}  o{}'.format(
                    _value_string([self.current]),
                    _value_string(self.registers),
                    _value_string(self.inbox),
                    _value_string(self.outbox)))
                print(self._current_instruction_string())
            run_index_save = self.run_index
            self.instructions[self.run_index].execute()
            # If it wasn't a jump move to the next instruction.
            if self.run_index == run_index_save:
                self.run_index += 1
            self.num_steps += 1
            if self.run_index < len(self.instructions):
                # Keep going
                return None
        except MachineExit:
            pass
        class Summary:
            def __init__(self, outbox, num_instructions, num_steps):
                self.outbox = copy.copy(outbox)
                self.num_instructions = num_instructions
                self.num_steps = num_steps
        return Summary(self.outbox, len(self.instructions), self.num_steps)

    def compile(self, blocks):
        for self.compile_location.block in blocks:
            block = self.compile_location.block
            print('%s:' % block.label)
            for self.compile_location.line_index in range(len(block.lines)):
                line = block.lines[self.compile_location.line_index]
                fields = line.split()
                op = fields[0].upper()
                args_provided = fields[1:]
                cls = self.__class__
                function = getattr(self, op, None)
                if not function:
                    raise CompileError('Bad operation: %s' % op)
                arg_names = list(inspect.signature(function).parameters)
                if len(args_provided) != len(arg_names):
                    raise CompileError('Expect arguments: %s' % ' '.join(arg_names))
                args = []
                for i in range(len(arg_names)):
                    arg_name = arg_names[i]
                    if arg_name == 'register':
                        value = self._get_register_num(args_provided[i])
                    elif arg_name == 'increment':
                        value = self._get_increment(args_provided[i])
                    elif arg_name == 'location':
                        value = self._get_location(args_provided[i])
                    else:
                        value = args_provided[i]
                    args.append(value)
                instruction = Instruction(op, function, args)
                self.instructions.append(instruction)
                print(self._instruction_trace_string(len(self.instructions), instruction))

    def run(self):
        try:
            if not self.instructions:
                print('Compiling...')
                self.compile(self.blocks)
            print('Running...')
            while True:
                summary = self.step()
                if summary:
                    return summary
        except CompileError as e:
            print('COMPILE ERROR at %s:%d "%s": %s' % (
                        self.compile_block.label,
                        self.compile_block_line_num + 1,
                        self.compile_block.lines[self.compile_block_line_num],
                        str(e)))
        except RunError as e:
            print('RUN ERROR: %s: %s' % (str(e), self._current_instruction_string()))

    ### Operations - raise MachineExit to exit

    def INBOX(self):
        self._write_current(self._read_inbox())

    def OUTBOX(self):
        self._write_outbox(self._read_current())
        self.current = None

    def COPY_TO(self, register):
        self._write_register(register, self._read_current())

    def COPY_FROM(self, register):
        self._write_current(self._read_register(register))

    def ADD(self, register):
        self._write_current(self._read_current_int() + self._read_register_int(register))

    def SUB(self, register):
        self._write_current(self._read_current_int() - self._read_register_int(register))

    def BUMP(self, increment, register):
        self._write_register(register, self._read_register_int(register) + increment)

    def JUMP(self, location):
        self._jump(location)

    def JUMP_IF_ZERO(self, location):
        if self._read_current_int() == 0:
            self._jump(location)

    def JUMP_IF_NEGATIVE(self, location):
        if self._read_current_int() < 0:
            self._jump(location)

    ### Private

    def _read_current(self):
        if self.current is None:
            raise RunError('No current value')
        return self.current

    def _read_current_int(self):
        try:
            return int(self._read_current())
        except ValueError:
            raise RunError('Current value is not an integer')

    def _write_current(self, value):
        if value is None:
            raise RunError('Current value can not be set to empty')
        self.current = '{}'.format(value)

    def _get_register_num(self, reg):
        try:
            reg_num = int(reg)
        except TypeError:
            raise CompileError('Register is not a number: %s' % reg)
        if reg_num < 0 or reg_num >= len(self.registers):
            raise CompileError('Bad register: #%d' % reg_num)
        return reg_num

    def _get_increment(self, increment):
        if increment == '-1':
            return -1
        if increment == '+1':
            return 1
        raise CompileError('BUMP increment must be -1 or +1')

    def _get_location(self, label):
        line_index = 0
        for block in self.blocks:
            if block.label == label:
                return line_index + 1
            line_index += len(block.lines)
        raise CompileError('Unknown block label "%s"' % label)

    def _read_register(self, reg_num):
        value = self.registers[reg_num]
        if value is None:
            raise RunError('No value to read from register: #%d' % reg_num)
        return value

    def _read_register_int(self, reg_num):
        svalue = self._read_register(reg_num)
        try:
            return int(svalue)
        except ValueError:
            raise RunError('Value is not an integer: %s' % svalue)

    def _write_register(self, reg_num, value):
        if value is None:
            raise RunError('No value to write to register: #%d' % reg_num)
        self.registers[reg_num] = '{}'.format(value)

    def _read_inbox(self):
        if not self.inbox:
            raise MachineExit('Inbox is empty')
        return self.inbox.pop(0)

    def _write_outbox(self, value):
        self.outbox.append(value)

    def _jump(self, location):
        if location <= 0 or location > len(self.instructions):
            raise RunError('Bad jump location %d, expect 1-%d' % (location, len(self.instructions)))
        self.run_index = location - 1

    def _current_instruction_string(self):
        instruction = self.instructions[self.run_index]
        return self._instruction_trace_string(self.run_index + 1, instruction)

    @classmethod
    def _instruction_trace_string(cls, line_num, instruction):
        sline_num = '(%d)' % line_num
        sargs = ' '.join(['{}'.format(arg) for arg in instruction.args])
        return '%6s %s %s' % (sline_num, instruction.op, sargs)


class Solution:
    def __init__(self, name, inbox, outbox, blocks):
        self.name = name
        self.inbox = inbox
        self.outbox = outbox
        self.blocks = blocks


class CodeBlock:
    def __init__(self, label, lines):
        self.label = label
        self.lines = lines


def box_string(box):
    return '(%s)' % (' '.join([str(item) for item in box]))


def test_solution(solution, trace=False):

    print('=== Solution: %s ===' % solution.name)

    machine = Machine(solution.inbox, solution.blocks, trace=trace)
    summary = machine.run()

    if summary:
        print('-- Summary:')
        def summarize(label, value):
            print('%12s: %s' % (label, value))
        summarize('Instructions', summary.num_instructions)
        summarize('Steps', summary.num_steps)
        summarize('Outbox', box_string(summary.outbox))
        if summary.outbox == solution.outbox:
            summarize('Result', 'PASSED')
            return True
        summarize('Expected', box_string(solution.outbox))
        summarize('Result', 'FAILED')
        return False


def test(path, names, trace):
    with open(path) as f:
        cfg = yaml.load(f)
    if not names:
        names = sorted(cfg.keys())
    for name in names:
        if name in cfg:
            sol = cfg[name]
            # It will be None if the YAML key is empty.
            if sol is None:
                sol = {}
            missing = [key for key in ['inbox', 'outbox', 'code'] if key not in sol]
            if not missing:
                inbox = sol['inbox'].split()
                outbox = sol['outbox'].split()
                # Code must be a series of labeled lists
                blocks = []
                for label in sol['code']:
                    blocks.append(CodeBlock(label, sol['code'][label]))
                solution = Solution(name, inbox, outbox, blocks)
                return test_solution(solution, trace=trace)
            else:
                print('Missing solution key%s: %s'
                            % ('s' if len(missing) > 1 else '', ' '.join(missing)))
                return False
        else:
            print('Solution not found: %s' % name)
            return False


if __name__ == '__main__':
    parser = ArgumentParser(description='Compile and run Human Resource Machine programs.')
    parser.add_argument('-t', '--trace', dest='trace', action='store_true',
                        default=False, help='trace execution')
    parser.add_argument(dest='targets', nargs='+', help='target path[:label1[:label2...]]')
    args = parser.parse_args()
    for target in args.targets:
        components = target.strip().split(':')
        if components:
            test(components[0], components[1:], args.trace)
